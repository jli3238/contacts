{"version":3,"sources":["style/rdg-image.less","components/enums.ts","components/formatters/ImageFormatter.tsx","components/formatters/SelectCellFormatter.tsx","components/formatters/ValueFormatter.tsx","components/Columns.tsx","components/utils/domUtils.ts","components/utils/columnUtils.ts","components/utils/keyboardUtils.ts","components/utils/selectedCellUtils.ts","components/utils/index.ts","components/hooks/useCombinedRefs.ts","components/hooks/useViewportColumns.ts","components/utils/viewportUtils.ts","components/EventBus.ts","components/headerCells/SortableHeaderCell.tsx","components/headerCells/ResizableHeaderCell.tsx","components/HeaderCell.tsx","components/HeaderRow.tsx","components/FilterRow.tsx","components/editors/SimpleTextEditor.tsx","components/editors/EditorPortal.tsx","components/editors/EditorContainer.tsx","components/hooks/useClickOutside.ts","components/Cell.tsx","components/Row.tsx","components/DataGrid.tsx","components/hooks/useGridWidth.ts","components/Contacts.tsx","containers/ContactsContainer.tsx"],"names":["module","exports","CellNavigationMode","UpdateActions","ImageFormatter","value","className","style","backgroundImage","SelectCellFormatter","tabIndex","isCellSelected","disabled","onChange","ariaLabel","ariaLabelledBy","inputRef","useRef","useLayoutEffect","current","focus","clsx","aria-label","aria-labelledby","ref","type","e","target","checked","nativeEvent","shiftKey","ValueFormatter","props","row","column","key","SelectColumn","name","width","maxWidth","headerRenderer","allRowsSelected","onAllRowsSelectionChange","formatter","isRowSelected","onRowSelectionChange","size","getScrollbarSize","undefined","scrollDiv","document","createElement","position","top","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","preventDefault","event","wrapEvent","ourHandler","theirHandler","getSpecifiedWidth","columnWidths","viewportWidth","has","get","test","Math","floor","parseInt","clampColumnWidth","minColumnWidth","minWidth","max","min","isCtrlKeyHeldDown","ctrlKey","metaKey","isSelectedCellEditable","selectedPosition","columns","rows","onCheckCellIsEditable","idx","rowIdx","editable","Boolean","editor","canEdit","assertIsValidKey","Error","wrapRefs","refs","handle","useCombinedRefs","useMemo","useViewportColumns","rawColumns","defaultFormatter","scrollLeft","metrics","left","totalWidth","allocatedWidths","unassignedColumnsCount","lastFrozenColumnIndex","metricsColumn","frozen","splice","push","unallocatedWidth","unallocatedColumnWidth","map","newColumn","totalColumnWidth","getColumnMetrics","viewportLeft","lastFrozenColumn","getTotalFrozenColumnWidth","viewportRight","lastColIdx","length","firstUnfrozenColumnIdx","colVisibleStartIdx","colVisibleEndIdx","getHorizontalRangeToRender","colOverscanStartIdx","colOverscanEndIdx","viewportColumns","colIdx","getViewportColumns","EventBus","subscribers","Map","handler","this","set","Set","handlers","add","delete","args","forEach","SORT_TEXT","ASC","DESC","NONE","SortableHeaderCell","onSort","sortColumn","sortDirection","children","onClick","direction","sortDescendingFirst","ResizableHeaderCell","onResize","cloneElement","onMouseDown","button","currentTarget","offset","getBoundingClientRect","right","clientX","onMouseMove","x","handleResize","window","addEventListener","onMouseUp","removeEventListener","onTouchStart","touch","changedTouches","identifier","getAriaSort","HeaderCell","cell","sortable","headerCellClass","role","aria-colindex","aria-sort","resizable","memo","rowKey","onSelectedRowsChange","onColumnResize","handleAllRowsSelectionChange","useCallback","newSelectedRows","aria-rowindex","filters","onFiltersChange","filterRenderer","newFilters","React","Component","EditorPortal","useState","isMounted","setIsMounted","ReactDOM","createPortal","EditorContainer","rowHeight","onCommit","onCommitCancel","scrollTop","editorRef","firstEditorKeyPress","changeCommitted","changeCanceled","isValid","setValid","prevScrollLeft","prevScrollTop","isUnmounting","onClickCapture","onClickOutside","isClickedInside","useEffect","handleDocumentClick","useClickOutside","commit","getInputNode","commitCancel","preventDefaultNavigation","inputNode","HTMLInputElement","selectionEnd","isCaretAtBeginningOfInput","selectionStart","isCaretAtEndOfInput","isSelectOpen","editorIsSelectOpen","includes","hasResults","editorHasResults","updated","getValue","validate","isNewValueValid","cellKey","HTMLElement","select","onKeyDown","stopPropagation","onContextMenu","forwardRef","isCopied","isDraggedOver","eventBus","selectedCellProps","onRowClick","onDoubleClick","cellRef","isSelected","isEditing","mode","cellClass","selectCell","openEditor","dispatch","isShiftClick","aria-selected","editorContainerProps","editorPortalTarget","editorProps","scrollingElement","documentElement","docTop","docLeft","gridLeft","gridTop","dragHandleProps","getCellContent","cellRenderer","CellRenderer","Cell","copiedCellIdx","draggedOverCellIdx","rowClass","setDraggedOverRowIdx","onMouseEnter","ariaRowIndex","ariaSelected","onRowsUpdate","headerRowHeight","headerFiltersHeight","selectedRows","rowRenderer","RowRenderer","Row","emptyRowsRenderer","onScroll","onSelectedCellChange","enableFilters","enableCellCopyPaste","enableCellDragAndDrop","cellNavigationMode","ariaDescribedBy","setScrollTop","setScrollLeft","setColumnWidths","setSelectedPosition","copiedPosition","setCopiedPosition","isDragging","setDragging","draggedOverRowIdx","setOverRowIdx","latestDraggedOverRowIdx","focusSinkRef","prevSelectedPosition","lastSelectedRowIdx","gridRef","gridWidth","setGridWidth","useGridWidth","headerRowsCount","isSelectable","totalHeaderHeight","clientHeight","rowsCount","rowVisibleStartIdx","rowVisibleEndIdx","ceil","getVerticalRangeToRender","rowOverscanStartIdx","rowOverscanEndIdx","handleKeyDown","isCellWithinBounds","lowerCaseKey","toLowerCase","handleCopy","isCellEditable","toRow","fromRow","fromCellKey","action","COPY_PASTE","handlePaste","nextPosition","getNextPosition","CHANGE_ROW","atLastCellInRow","canExitGrid","columnsCount","isBeforeFirstColumn","LOOP_OVER_ROW","getNextSelectedCellPosition","navigate","handleCellInput","scrollToCell","formatterOptions","focusable","subscribe","rowId","previousRowIdx","step","sign","i","useImperativeHandle","scrollToColumn","scrollToRow","handleColumnResize","newColumnWidths","handleCommit","CELL_UPDATE","closeEditor","handleMouseDown","onMouseOver","buttons","CELL_DRAG","handleDragEnd","handleDoubleClick","COLUMN_FILL","enableEditor","lastFrozenCol","getFrozenColumnsWidth","newScrollLeft","currentScrollLeft","currentClientWidth","selectedColumn","scrollRight","getColumnScrollPosition","getDraggedOverCellIdx","currentRowIdx","getSelectedCellProps","aria-describedby","aria-multiselectable","aria-colcount","aria-rowcount","rowElements","getViewportRows","createFakeRowObjectData","index","id","avatar","faker","image","contact","firstName","lastName","totalValue","random","toString","location","address","city","state","country","deals","tags","lorem","words","isAtBottom","scrollHeight","loadMoreRows","newRowsCount","Promise","resolve","newRows","setTimeout","Contacts","numberOfRows","createRows","setRows","setSelectedRows","isLoading","setIsLoading","handleRowUpdate","start","end","handleRowClick","handleScroll","a","ContactsContainer"],"mappings":"uGAAAA,EAAOC,QAAU,IAA0B,wC,sFCA/BC,EAMAC,E,4EANAD,K,YAAAA,E,uBAAAA,E,6BAAAA,M,cAMAC,K,0BAAAA,E,0BAAAA,E,wBAAAA,E,uBAAAA,M,YCEL,SAASC,EAAT,GAA2C,IAAjBC,EAAgB,EAAhBA,MAC/B,OACE,yBAAKC,UAAU,0BACb,yBAAKA,UAAU,iBAAiBC,MAAO,CAAEC,gBAAgB,OAAD,OAASH,EAAT,S,YCKvD,SAASI,EAAT,GAQuB,IAP5BJ,EAO2B,EAP3BA,MACAK,EAM2B,EAN3BA,SACAC,EAK2B,EAL3BA,eACAC,EAI2B,EAJ3BA,SACAC,EAG2B,EAH3BA,SACcC,EAEa,EAF3B,cACmBC,EACQ,EAD3B,mBAEMC,EAAWC,iBAAyB,MAW1C,OATAC,2BAAgB,WAAO,IAAD,EACfP,IACL,UAAAK,EAASG,eAAT,SAAkBC,WACjB,CAACT,IAOF,2BAAOL,UAAWe,YAAK,qBAAsB,CAAE,8BAA+BT,KAC5E,2BACEU,aAAYR,EACZS,kBAAiBR,EACjBL,SAAUA,EACVc,IAAKR,EACLS,KAAK,WACLnB,UAAU,qBACVM,SAAUA,EACVC,SAdN,SAAsBa,GACpBb,EAASa,EAAEC,OAAOC,QAAUF,EAAEG,YAA2BC,WAcrDF,QAASvB,IAEX,yBAAKC,UAAU,kBC9Cd,SAASyB,EAAkBC,GAChC,OAAO,oCAAGA,EAAMC,IAAID,EAAME,OAAOC,MCE5B,IAAMC,EAA4B,CACvCD,IAAK,aACLE,KAAM,GACNC,MAAO,GACPC,SAAU,GACVC,eALuC,SAKxBR,GACb,OACE,kBAACvB,EAAD,CACEa,aAAW,aACXjB,MAAO2B,EAAMS,gBACb5B,SAAUmB,EAAMU,4BAItBC,UAduC,SAc7BX,GACR,OACE,kBAACvB,EAAD,CACEa,aAAW,SACXZ,UAAW,EACXC,eAAgBqB,EAAMrB,eACtBN,MAAO2B,EAAMY,cACb/B,SAAUmB,EAAMa,yB,YC3BpBC,E,QAEG,SAASC,IACd,QAAaC,IAATF,EAAoB,CACtB,IAAMG,EAAYC,SAASC,cAAc,OAEzCF,EAAU1C,MAAM6C,SAAW,WAC3BH,EAAU1C,MAAM8C,IAAM,UACtBJ,EAAU1C,MAAM+B,MAAQ,OACxBW,EAAU1C,MAAM+C,OAAS,OACzBL,EAAU1C,MAAMgD,SAAW,SAE3BL,SAASM,KAAKC,YAAYR,GAC1BH,EAAOG,EAAUS,YAAcT,EAAUU,YACzCT,SAASM,KAAKI,YAAYX,GAG5B,OAAOH,EAGF,SAASe,EAAeC,GAC7BA,EAAMD,iBAGD,SAASE,EAA0CC,EAAmCC,GAC3F,YAAqBjB,IAAjBiB,EAAmCD,EAEhC,SAASF,GACdE,EAAWF,GACXG,EAAaH,IC2CjB,SAASI,EAAT,EAEEC,EACAC,GACqB,IAHnBjC,EAGkB,EAHlBA,IAAKG,EAGa,EAHbA,MAIP,OAAI6B,EAAaE,IAAIlC,GAEZgC,EAAaG,IAAInC,GAEL,kBAAVG,EACFA,EAEY,kBAAVA,GAAsB,SAASiC,KAAKjC,GACtCkC,KAAKC,MAAML,EAAgBM,SAASpC,EAAO,IAAM,UAD1D,EAMF,SAASqC,EACPrC,EADF,EAGEsC,GACS,IAFPC,EAEM,EAFNA,SAAUtC,EAEJ,EAFIA,SAKZ,OAFAD,EAAQkC,KAAKM,IAAIxC,EAAT,OAAgBuC,QAAhB,IAAgBA,IAAYD,GAEZ,kBAAbrC,EACFiC,KAAKO,IAAIzC,EAAOC,GAGlBD,EC5FF,SAAS0C,EAAkBtD,GAChC,QAAsB,IAAdA,EAAEuD,UAAkC,IAAdvD,EAAEwD,UAA+B,YAAVxD,EAAES,ICClD,SAASgD,EAAT,GAAwI,IAAnGC,EAAkG,EAAlGA,iBAAkBC,EAAgF,EAAhFA,QAASC,EAAuE,EAAvEA,KAAMC,EAAiE,EAAjEA,sBACrErD,EAASmD,EAAQD,EAAiBI,KAClCvD,EAAMqD,EAAKF,EAAiBK,QAElC,QADuBF,GAAwBA,EAAsB,aAAEtD,MAAKC,UAAWkD,MF4FlF,SAAoBlD,EAA6BD,GACtD,MAA+B,oBAApBC,EAAOwD,SACTxD,EAAOwD,SAASzD,GAElB0D,QAAQzD,EAAO0D,QAAU1D,EAAOwD,UE/FdG,CAAW3D,EAAQD,GCTvC,SAAS6D,EAAoB3D,GAClC,QAAYa,IAARb,EACF,MAAM,IAAI4D,MAAM,mDAIb,SAASC,IAA+C,IAAD,uBAA/BC,EAA+B,yBAA/BA,EAA+B,gBAC5D,OAAO,SAACC,GAAsB,IAAD,gBACXD,GADW,IAC3B,2BAAsB,CAAC,IAAdzE,EAAa,QACD,oBAARA,EACTA,EAAI0E,GACa,OAAR1E,IAGTA,EAAG,2BAAOA,GAAP,IAAYL,QAAS+E,MAPD,gCCVxB,SAASC,IAAsD,IAAD,uBAA/BF,EAA+B,yBAA/BA,EAA+B,gBACnE,OAAOG,mBACL,kBAAMJ,EAAQ,WAAR,EAAeC,KAErBA,GCQG,SAASI,EAAT,GAOwB,IANpBC,EAMmB,EAN5BjB,QACAT,EAK4B,EAL5BA,eACAT,EAI4B,EAJ5BA,aACAC,EAG4B,EAH5BA,cACAmC,EAE4B,EAF5BA,iBACAC,EAC4B,EAD5BA,WAC4B,EACiCJ,mBAAQ,WACnE,OLPG,SAA6BK,GAClC,IADyE,EACrEC,EAAO,EACPC,EAAa,EACbC,EAAkB,EAClBC,EAAyB,EACzBC,GAAyB,EACvBzB,EAA2E,GANR,cAQ7CoB,EAAQpB,SARqC,IAQzE,2BAA6C,CAAC,IAAnC0B,EAAkC,QACvCzE,EAAQ4B,EAAkB6C,EAAeN,EAAQtC,aAAcsC,EAAQrC,oBAE7DpB,IAAVV,EACFuE,IAGAD,GADAtE,EAAQqC,EAAiBrC,EAAOyE,EAAeN,EAAQ7B,gBAIzD,IAAM1C,EAAM,2BAAQ6E,GAAR,IAAuBzE,UAC/BJ,EAAO8E,QACTF,IACAzB,EAAQ4B,OAAOH,EAAuB,EAAG5E,IAEzCmD,EAAQ6B,KAAKhF,IAvBwD,8BA2BzE,IAAMiF,EAAmBV,EAAQrC,cAAgBwC,EAAkB7D,IAC7DqE,EAAyB5C,KAAKM,IAClCN,KAAKC,MAAM0C,EAAmBN,GAC9BJ,EAAQ7B,gBAkBV,MAAO,CACLS,QAhB+CA,EAAQgC,KAAI,SAACnF,EAAQsD,GAAS,IAAD,IAEtElD,EAAK,UAAGJ,EAAOI,aAAV,QAAmBqC,EAAiByC,EAAwBlF,EAAQuE,EAAQ7B,gBACjF0C,EAAS,2BACVpF,GADU,IAEbsD,MACAlD,QACAoE,OACA/D,UAAS,UAAET,EAAOS,iBAAT,QAAsB8D,EAAQF,mBAIzC,OAFAI,GAAcrE,EACdoE,GAAQpE,EACDgF,KAKPR,wBACAS,iBAAkBZ,GK5CXa,CAAoB,CACzBnC,QAASiB,EACT1B,iBACAR,gBACAD,eACAoC,uBAED,CAACpC,EAAcmC,EAAYC,EAAkB3B,EAAgBR,IARxDiB,EADoB,EACpBA,QAASyB,EADW,EACXA,sBAAuBS,EADZ,EACYA,iBADZ,EAWqBnB,mBAAQ,WACvD,OCPG,SACLf,EACAyB,EACA1C,EACAoC,GAGA,IACMiB,EAAejB,EAjCvB,SAAsCnB,EAAyCyB,GAC7E,IAA+B,IAA3BA,EACF,OAAO,EAET,IAAMY,EAAmBrC,EAAQyB,GACjC,OAAOY,EAAiBhB,KAAOgB,EAAiBpF,MA2BjBqF,CAA0BtC,EAASyB,GAE5Dc,EAAgBpB,EAAapC,EAE7ByD,EAAaxC,EAAQyC,OAAS,EAC9BC,EAAyBvD,KAAKO,IAAI+B,EAAwB,EAAGe,GAGnE,GAAIJ,GAAgBG,EAClB,MAAO,CAACG,EAAwBA,GAKlC,IADA,IAAIC,EAAqBD,EAClBC,EAAqBH,GAAY,CAAC,IAAD,EACdxC,EAAQ2C,GAGhC,GAJsC,EAC9BtB,KAD8B,EACxBpE,MAGKmF,EACjB,MAEFO,IAKF,IADA,IAAIC,EAAmBD,EAChBC,EAAmBJ,GAAY,CAAC,IAAD,EACZxC,EAAQ4C,GAGhC,GAJoC,EAC5BvB,KAD4B,EACtBpE,OAGMsF,EAClB,MAEFK,IAMF,MAAO,CAHqBzD,KAAKM,IAAIiD,EAAwBC,EAAqB,GACxDxD,KAAKO,IAAI8C,EAAYI,EAAmB,IDrCzDC,CACL7C,EACAyB,EACA1C,EACAoC,KAED,CAACA,EAAYnB,EAASyB,EAAuB1C,IAlBpB,mBAWrB+D,EAXqB,KAWAC,EAXA,KAoBtBC,EAAkBjC,mBAAQ,WAC9B,OCiCG,SAA+Bf,EAAyC8C,EAA6BC,GAE1G,IADA,IAAMC,EAAyC,GACtCC,EAAS,EAAGA,GAAUF,EAAmBE,IAAU,CAC1D,IAAMpG,EAASmD,EAAQiD,GAEnBA,EAASH,IAAwBjG,EAAO8E,QAC5CqB,EAAgBnB,KAAKhF,GAGvB,OAAOmG,ED1CEE,CACLlD,EACA8C,EACAC,KAED,CAACA,EAAmBD,EAAqB9C,IAE5C,MAAO,CAAEA,UAASgD,kBAAiBd,mBAAkBT,yB,oBEzClC0B,E,iDACFC,YAAc,IAAIC,I,sDAEJjH,EAASkH,GACjCC,KAAKH,YAAYpE,IAAI5C,IACxBmH,KAAKH,YAAYI,IAAIpH,EAAM,IAAIqH,KAGjC,IAAMC,EAAWH,KAAKH,YAAYnE,IAAI7C,GAGtC,OAFAsH,EAASC,IAAIL,GAEN,WACLI,EAASE,OAAON,M,+BAIUlH,GAA4C,IAAD,uBAA/ByH,EAA+B,iCAA/BA,EAA+B,kBACvE,IAAMH,EAAWH,KAAKH,YAAYnE,IAAI7C,GAClCsH,GAEFA,EAASI,SAAQ,SAAAR,GACdA,EAAD,aAA2DO,U,KC1B7DE,EAAY,CAChBC,IAAK,SACLC,KAAM,SACNC,KAAM,IAcO,SAASC,EAAT,GAMD,IALZtH,EAKW,EALXA,OACAuH,EAIW,EAJXA,OACAC,EAGW,EAHXA,WACAC,EAEW,EAFXA,cACAC,EACW,EADXA,SAqBA,OAnBAD,EAAiBD,IAAexH,EAAOC,KAAOwH,GAAkB,OAoB9D,0BAAMrJ,UAAU,uBAAuBuJ,QAnBzC,WACE,GAAKJ,EAAL,CACA,IACIK,EADEC,EAAsB7H,EAAO6H,sBAAuB,EAE1D,OAAQJ,GACN,IAAK,MACHG,EAAYC,EAAsB,OAAS,OAC3C,MACF,IAAK,OACHD,EAAYC,EAAsB,MAAQ,OAC1C,MACF,QACED,EAAYC,EAAsB,OAAS,MAG/CN,EAAOvH,EAAOC,IAAK2H,MAKjB,0BAAMxJ,UAAU,wBAAwBsJ,GACxC,8BAAOR,EAAUO,KCzCR,SAASK,EAAT,GAIkB,IAH/BJ,EAG8B,EAH9BA,SACA1H,EAE8B,EAF9BA,OACA+H,EAC8B,EAD9BA,SAgDA,OAAOC,uBAAaN,EAAU,CAC5BO,YA/CF,SAAqBrG,GACnB,GAAqB,IAAjBA,EAAMsG,OAAV,CAD4C,IAKpCC,EAAkBvG,EAAlBuG,cAEFC,EADYD,EAAcE,wBAAxBC,MACe1G,EAAM2G,QAE7B,KAAIH,EAAS,IAAb,CAIA,IAAMI,EAAc,SAAC5G,IA0BvB,SAAsB6G,EAAWhJ,GAC/B,IAAMW,EAAQqI,EAAIhJ,EAAO4I,wBAAwB7D,KAC7CpE,EAAQ,GACV2H,EAAS/H,EAAQI,GA5BjBsI,CAAa9G,EAAM2G,QAAUH,EAAQD,IAQvCvG,EAAMD,iBACNgH,OAAOC,iBAAiB,YAAaJ,GACrCG,OAAOC,iBAAiB,WAPN,SAAZC,IACJF,OAAOG,oBAAoB,YAAaN,GACxCG,OAAOG,oBAAoB,UAAWD,SA6BxCE,aArBF,SAAsBnH,GACpB,IAAMoH,EAAQpH,EAAMqH,eAAe,GACZD,EAAfE,WACkBtH,EAAlBuG,cACwBE,wBAAxBC,MACeU,EAAMT,SAiB7Bb,SACE,oCACGA,EAAS5H,MAAM4H,SAChB,yBAAKtJ,UAAU,+BC1DvB,SAAS+K,EAAY1B,GACnB,OAAQA,GACN,IAAK,MACH,MAAO,YACT,IAAK,OACH,MAAO,aACT,QACE,MAAO,QAkBE,SAAS2B,EAAT,GASS,IARtBpJ,EAQqB,EARrBA,OACA4E,EAOqB,EAPrBA,sBACAmD,EAMqB,EANrBA,SACAxH,EAKqB,EALrBA,gBACAC,EAIqB,EAJrBA,yBACAgH,EAGqB,EAHrBA,WACAC,EAEqB,EAFrBA,cACAF,EACqB,EADrBA,OAQA,IAAI8B,EALGrJ,EAAOM,eAELW,wBAAcjB,EAAOM,eAAgB,CAAEN,SAAQO,kBAAiBC,6BAFpCR,EAAOG,KAOxCH,EAAOsJ,WACTD,EACE,kBAAC/B,EAAD,CACEtH,OAAQA,EACRuH,OAAQA,EACRC,WAAYA,EACZC,cAAeA,GAEd4B,IAKP,IAAMjL,EAAYe,YAAK,WAAYa,EAAOuJ,gBAAiB,CACzD,kBAAmBvJ,EAAO8E,OAC1B,uBAAwB9E,EAAOsD,MAAQsB,IAGnCvG,EAA6B,CACjC+B,MAAOJ,EAAOI,MACdoE,KAAMxE,EAAOwE,MA0Bf,OAvBA6E,EACE,yBACEG,KAAK,eACLC,gBAAezJ,EAAOsD,IAAM,EAC5BoG,YAAWlC,IAAexH,EAAOC,IAAMkJ,EAAY1B,QAAiB3G,EACpE1C,UAAWA,EACXC,MAAOA,GAENgL,GAIDrJ,EAAO2J,YACTN,EACE,kBAACvB,EAAD,CACE9H,OAAQA,EACR+H,SAAUA,GAETsB,IAKAA,EC1BMO,sBAjDf,YAW0B,IAVxBzG,EAUuB,EAVvBA,QACAyB,EASuB,EATvBA,sBACAxB,EAQuB,EARvBA,KACAyG,EAOuB,EAPvBA,OACAC,EAMuB,EANvBA,qBACAvJ,EAKuB,EALvBA,gBACAwJ,EAIuB,EAJvBA,eACAvC,EAGuB,EAHvBA,WACAC,EAEuB,EAFvBA,cACAF,EACuB,EADvBA,OAEMyC,EAA+BC,uBAAY,SAACvK,GAChD,GAAKoK,EAAL,CACAlG,EAAiBiG,GACjB,IAAMK,EAAkB,IAAItD,IAC5B,GAAIlH,EAAS,CAAC,IAAD,gBACO0D,GADP,IACX,2BAAwB,CAAC,IAAdrD,EAAa,QACtBmK,EAAgBpD,IAAI/G,EAAI8J,KAFf,+BAKbC,EAAqBI,MACpB,CAACJ,EAAsB1G,EAAMyG,IAEhC,OACE,yBACEL,KAAK,MACLW,gBAAe,EACf/L,UAAU,kBAET+E,EAAQgC,KAAI,SAAAnF,GACX,OACE,kBAACoJ,EAAD,CACEnJ,IAAKD,EAAOC,IACZD,OAAQA,EACR4E,sBAAuBA,EACvBmD,SAAUgC,EACVxJ,gBAAiBA,EACjBC,yBAA0BwJ,EAC1BzC,OAAQA,EACRC,WAAYA,EACZC,cAAeA,WCCZmC,sBAhDf,YAKuB,IAJrBzG,EAIoB,EAJpBA,QACAyB,EAGoB,EAHpBA,sBACAwF,EAEoB,EAFpBA,QACAC,EACoB,EADpBA,gBAQA,OACE,yBACEb,KAAK,MACLW,gBAAe,EACf/L,UAAU,kBAET+E,EAAQgC,KAAI,SAAAnF,GAAW,IACdC,EAAQD,EAARC,IAEF7B,EAAYe,YAAK,WAAY,CACjC,kBAAmBa,EAAO8E,OAC1B,uBAAwB9E,EAAOsD,MAAQsB,IAEnCvG,EAA6B,CACjC+B,MAAOJ,EAAOI,MACdoE,KAAMxE,EAAOwE,MAGf,OACE,yBACEvE,IAAKA,EACL5B,MAAOA,EACPD,UAAWA,GAEV4B,EAAOsK,gBAAkBrJ,wBAAcjB,EAAOsK,eAAgB,CAC7DtK,SACA7B,MAAK,OAAEiM,QAAF,IAAEA,OAAF,EAAEA,EAAUpK,EAAOC,KACxBtB,SAAU,SAAAR,GAAK,OAjC3B,SAAkB8B,EAAa9B,GAC7B,IAAMoM,EAAmB,eAAQH,GACjCG,EAAWtK,GAAO9B,EACH,OAAfkM,QAAe,IAAfA,KAAkBE,GA8BW5L,CAASsB,EAAK9B,c,gCClDDqM,IAAMC,U,eCGrC,SAASC,EAAT,GAAoD,IAA5BjL,EAA2B,EAA3BA,OAAQiI,EAAmB,EAAnBA,SAAmB,EAE9BiD,oBAAS,GAFqB,mBAEzDC,EAFyD,KAE9CC,EAF8C,KAUhE,OANA7L,2BAAgB,WACd6L,GAAa,KACZ,IAIED,EAIEE,IAASC,aAAarD,EAAUjI,GAH9B,KCJI,SAASuL,EAAT,GAYc,IAX3BzH,EAW0B,EAX1BA,OACAvD,EAU0B,EAV1BA,OAEAiL,GAQ0B,EAT1BlL,IAS0B,EAR1BkL,WACAzG,EAO0B,EAP1BA,KACArD,EAM0B,EAN1BA,IACA+J,EAK0B,EAL1BA,SACAC,EAI0B,EAJ1BA,eACA7G,EAG0B,EAH1BA,WACA8G,EAE0B,EAF1BA,UAGMC,GADoB,EAD1BC,oBAEkBvM,iBAAe,OAC3BwM,EAAkBxM,kBAAO,GACzByM,EAAiBzM,kBAAO,GAHJ,EAIE4L,oBAAS,GAJX,mBAInBc,EAJmB,KAIVC,EAJU,KAKpBC,EAAiB5M,iBAAOuF,GACxBsH,EAAgB7M,iBAAOqM,GACvBS,EAAe9M,kBAAO,GACtB+M,ECgBD,SAAyBC,GAC9B,IAAMC,EAAkBjN,kBAAO,GAiB/B,OAfAkN,qBAAU,WACR,SAASC,IACHF,EAAgB/M,QAClB+M,EAAgB/M,SAAU,EAE1B8M,IAKJ,OADA/K,SAAS4H,iBAAiB,QAASsD,GAC5B,WACLlL,SAAS8H,oBAAoB,QAASoD,OAInC,WACLF,EAAgB/M,SAAU,GDnCLkN,CAAgBC,GAEjCC,EAAepC,uBAAY,kCAAMoB,EAAUpM,eAAhB,aAAM,EAAmBoN,iBAAgB,IAEpEC,EAAerC,uBAAY,WAC/BuB,EAAevM,SAAU,EACzBkM,MACC,CAACA,IAwEJ,SAASoB,EAAyBtM,GAChC,MAAgB,cAARA,IA9BV,WACE,IAAMuM,EAAYH,IAClB,OAAOG,aAAqBC,kBACI,IAA3BD,EAAUE,aA2BiBC,IAClB,eAAR1M,IAzBR,WACE,IAAMuM,EAAYH,IAClB,OAAOG,aAAqBC,kBACvBD,EAAUI,iBAAmBJ,EAAUrO,MAAMyH,OAsBnBiH,IACjB,WAAR5M,GAhBR,WAAwC,IAAD,MACrC,2BAAOoL,EAAUpM,eAAjB,iBAAO,EAAmB6N,oBAA1B,aAAO,iBAAP,SAe0BC,IACpB,CAAC,UAAW,aAAaC,SAAS/M,IArB1C,WAAsC,IAAD,MACnC,2BAAOoL,EAAUpM,eAAjB,iBAAO,EAAmBgO,kBAA1B,aAAO,iBAAP,SAoBgDC,GAGlD,SAASd,IACP,GAAKf,EAAUpM,QAAf,CACA,IAAMkO,EAAU9B,EAAUpM,QAAQmO,WAClC,GAnBF,SAAyBjP,GAA0B,IAAD,IAC1CsN,EAAO,UAAGJ,EAAUpM,eAAb,iBAAG,EAAmBoO,gBAAtB,aAAG,SAA8BlP,GAC9C,MAAuB,mBAAZsN,IACTC,EAASD,GACFA,GAeL6B,CAAgBH,GAAU,CAC5B5B,EAAgBtM,SAAU,EAC1B,IAAMsO,EAAUvN,EAAOC,IACvBiL,EAAS,CAAEqC,UAAShK,SAAQ4J,cAnFhCnO,2BAAgB,WACd,IAAMwN,EAAYH,IAEdG,aAAqBgB,aACvBhB,EAAUtN,QAERsN,aAAqBC,kBACvBD,EAAUiB,WAEX,CAACpB,IAGJJ,qBAAU,WACJ3H,IAAeqH,EAAe1M,SAAWmM,IAAcQ,EAAc3M,SACvEqN,MAED,CAACA,EAAchI,EAAY8G,IAE9Ba,qBAAU,kBAAM,WACdJ,EAAa5M,SAAU,KACtB,IAGHgN,qBAAU,kBAAM,YACVJ,EAAa5M,SAAYsM,EAAgBtM,SAAYuM,EAAevM,SACtEmN,QAwEJ,IAAMhO,EAAYe,YAAK,uBAAwB,CAC7C,sBAAuBsM,IAGzB,OACE,yBACErN,UAAWA,EACXC,MAAO,CAAE+C,OAAQ6J,EAAW7K,MAAOJ,EAAOI,MAAOoE,OAAMrD,OACvD2K,eAAgBA,EAChB4B,UAnBJ,SAAmBlO,GACb+M,EAAyB/M,EAAES,KAC7BT,EAAEmO,kBACO,CAAC,QAAS,MAAO,UAAW,YAAa,YAAa,cAAcX,SAASxN,EAAES,KACxFmM,IACmB,WAAV5M,EAAES,KACXqM,KAcAsB,cAAejM,IE1BNiI,qBAAKiE,sBAtHpB,WAiByBvO,GAAiC,IAhBxDlB,EAgBuD,EAhBvDA,UACA4B,EAeuD,EAfvDA,OACA8N,EAcuD,EAdvDA,SACAC,EAauD,EAbvDA,cACArN,EAYuD,EAZvDA,cACAkE,EAWuD,EAXvDA,sBACA7E,EAUuD,EAVvDA,IACAwD,EASuD,EATvDA,OACAyK,EAQuD,EARvDA,SACAC,EAOuD,EAPvDA,kBACAC,EAMuD,EANvDA,WACAR,EAKuD,EALvDA,UACA/F,EAIuD,EAJvDA,QACAwG,EAGuD,EAHvDA,cACAP,EAEuD,EAFvDA,cACG9N,EACoD,0NACjDsO,EAAUrP,iBAAuB,MACjCsP,OAAmCvN,IAAtBmN,EACbK,EAAwC,UAAX,OAAjBL,QAAiB,IAAjBA,OAAA,EAAAA,EAAmBM,MAE7BC,EAAcxO,EAAdwO,UAcR,SAASC,EAAWC,GAClBV,EAASW,SAAS,cAAe,CAAErL,IAAKtD,EAAOsD,IAAKC,UAAUmL,GAgBhE,SAAS/N,EAAqBjB,EAAkBkP,GAC9CZ,EAASW,SAAS,aAAc,CAAEpL,SAAQ7D,UAASkP,iBA0CrD,OAzEAxQ,EAAYe,YACV,WACA,CACE,kBAAmBa,EAAO8E,OAC1B,uBAAwB9E,EAAOsD,MAAQsB,EACvC,oBAAqByJ,EACrB,kBAAmBP,EACnB,wBAAyBC,GAEN,oBAAdS,EAA2BA,EAAUzO,GAAOyO,EACnDpQ,GAgEA,uCACEoL,KAAK,WACLC,gBAAezJ,EAAOsD,IAAM,EAC5BuL,gBAAeR,EACf/O,IAAK2E,EAAgBmK,EAAS9O,GAC9BlB,UAAWA,EACXC,MAAO,CACL+B,MAAOJ,EAAOI,MACdoE,KAAMxE,EAAOwE,MAEfkJ,UAAWO,EAAoBpM,EAAUoM,EAAkBP,UAAWA,GAAaA,EACnF/F,QAAS2G,EAAY3G,EAAU9F,GApEnC,WACE4M,IACU,OAAVP,QAAU,IAAVA,KAAa3K,EAAQxD,EAAKC,KAkE8B2H,GACtDwG,cAAeG,EAAYH,EAAgBtM,GA5D/C,WACE4M,GAAW,KA2D+DN,GACxEP,cAAeU,EAAYV,EAAgB/L,GAjE/C,WACE4M,MAgE0Eb,IACpE9N,GAtDR,WACE,GAAImO,GAAgD,SAA3BA,EAAkBM,KAAiB,CAAC,IAAD,EACXN,EAAkBa,qBAAzDC,EADkD,EAClDA,mBAAuBC,EAD2B,wCAEPhO,SAASiO,kBAAoBjO,SAASkO,gBAAtEC,EAFuC,EAElD/D,UAA+BgE,EAFmB,EAE/B9K,WAF+B,EAGpC8J,EAAQnP,QAASoJ,wBACjCgH,EAJoD,EAGlD7K,KACgB4K,EAClBE,EALoD,EAG5CnO,IAEQgO,EAEtB,OACE,kBAACzE,EAAD,CAAcjL,OAAQsP,GACpB,kBAAC/D,EAAD,iBACMgE,EADN,CAEEzL,OAAQA,EACRxD,IAAKA,EACLC,OAAQA,EACRwE,KAAM6K,EACNlO,IAAKmO,MAMb,OACE,oCACE,kBAACtP,EAAOS,UAAR,CACET,OAAQA,EACRuD,OAAQA,EACRxD,IAAKA,EACLtB,eAAgB4P,EAChB3N,cAAeA,EACfC,qBAAsBA,KAEN,OAAjBsN,QAAiB,IAAjBA,OAAA,EAAAA,EAAmBsB,kBAClB,uCAAKnR,UAAU,wBAA2B6P,EAAkBsB,mBAuB/DC,QCrDQ5F,sBA7Df,YAoByB,IAAD,IAnBtB6F,aAAcC,OAmBQ,MAnBOC,EAmBP,EAlBtBvR,EAkBsB,EAlBtBA,UACA4P,EAiBsB,EAjBtBA,SACAzK,EAgBsB,EAhBtBA,OACA7C,EAesB,EAftBA,cACAkE,EAcsB,EAdtBA,sBACAgL,EAasB,EAbtBA,cACAC,EAYsB,EAZtBA,mBACA9P,EAWsB,EAXtBA,IACAoG,EAUsB,EAVtBA,gBACA8H,EASsB,EATtBA,kBACAC,EAQsB,EARtBA,WACA4B,EAOsB,EAPtBA,SACAC,EAMsB,EANtBA,qBACAC,EAKsB,EALtBA,aACA7O,EAIsB,EAJtBA,IACiB8O,EAGK,EAHtB,iBACiBC,EAEK,EAFtB,iBACGpQ,EACmB,6RAYtB,OARA1B,EAAYe,YACV,UADc,kBAEHoE,EAAS,IAAM,EAAI,OAAS,OACvC,CAAE,mBAAoB7C,GAHR,OAIdoP,QAJc,IAIdA,OAJc,EAIdA,EAAW/P,GACX3B,GAIA,uCACEoL,KAAK,MACLW,gBAAe8F,EACfpB,gBAAeqB,EACf9R,UAAWA,EACX4R,aAAcnO,GAjBlB,WACsB,OAApBkO,QAAoB,IAApBA,KAAuBxM,KAgBoByM,GACzC3R,MAAO,CAAE8C,QACLrB,GAEHqG,EAAgBhB,KAAI,SAAAnF,GAAM,OACzB,kBAAC0P,EAAD,CACEzP,IAAKD,EAAOC,IACZsD,OAAQA,EACRvD,OAAQA,EACR4E,sBAAuBA,EACvB7E,IAAKA,EACL+N,SAAU8B,IAAkB5P,EAAOsD,IACnCyK,cAAe8B,IAAuB7P,EAAOsD,IAC7C5C,cAAeA,EACfsN,SAAUA,EACVC,mBAAoC,OAAjBA,QAAiB,IAAjBA,OAAA,EAAAA,EAAmB3K,OAAQtD,EAAOsD,IAAM2K,OAAoBnN,EAC/EoN,WAAYA,WCiqBPL,4BApkBf,WA2CwBvO,GAAiC,IAzC5C8E,EAyC2C,EAzCpDjB,QACAC,EAwCoD,EAxCpDA,KACAyG,EAuCoD,EAvCpDA,OACAsG,EAsCoD,EAtCpDA,aAEA/P,EAoCoD,EApCpDA,MAoCoD,IAnCpDgB,cAmCoD,MAnC3C,IAmC2C,MAlCpDsB,sBAkCoD,MAlCnC,GAkCmC,MAjCpDuI,iBAiCoD,MAjCxC,GAiCwC,MAhCpDmF,uBAgCoD,MAhClC,GAgCkC,MA/BpDC,2BA+BoD,MA/B9B,GA+B8B,EA7BpDC,EA6BoD,EA7BpDA,aACAxG,EA4BoD,EA5BpDA,qBACAtC,EA2BoD,EA3BpDA,WACAC,EA0BoD,EA1BpDA,cACAF,EAyBoD,EAzBpDA,OACA6C,EAwBoD,EAxBpDA,QACAC,EAuBoD,EAvBpDA,gBAuBoD,IArBpDhG,wBAqBoD,MArBjCxE,EAqBiC,MApBpD0Q,YAAaC,OAoBuC,MApBzBC,EAoByB,EAnBpDC,EAmBoD,EAnBpDA,kBAEAxC,EAiBoD,EAjBpDA,WACAyC,EAgBoD,EAhBpDA,SACA5G,EAeoD,EAfpDA,eACA6G,EAcoD,EAdpDA,qBACAvN,EAaoD,EAbpDA,sBAaoD,IAXpDwN,qBAWoD,cAVpDC,4BAUoD,gBATpDC,8BASoD,gBARpDC,2BAQoD,OAR/BhT,EAAmBqJ,KAQY,QANpD0H,2BAMoD,OAN/B/N,SAASM,KAMsB,GALpDwO,GAKoD,EALpDA,SAEclR,GAGsC,EAHpD,cACmBC,GAEiC,EAFpD,mBACoBoS,GACgC,EADpD,oBACoD,GAInCtG,oBAAS,kBAAM,IAAIrE,KAA/B0H,GAJ+C,wBAKpBrD,mBAAS,GALW,qBAK/CS,GAL+C,MAKpC8F,GALoC,SAMlBvG,mBAAS,GANS,qBAM/CrG,GAN+C,MAMnC6M,GANmC,SAOdxG,oBAAsC,kBAAM,IAAInE,OAPlC,qBAO/CvE,GAP+C,MAOjCmP,GAPiC,SAQNzG,mBAA0C,CAAErH,KAAM,EAAGC,QAAS,EAAGgL,KAAM,WARjE,qBAQ/CrL,GAR+C,MAQ7BmO,GAR6B,SASV1G,mBAA+C,MATrC,qBAS/C2G,GAT+C,MAS/BC,GAT+B,SAUpB5G,oBAAS,GAVW,qBAU/C6G,GAV+C,MAUnCC,GAVmC,SAWX9G,wBAA6B7J,GAXlB,qBAW/C4Q,GAX+C,MAW5BC,GAX4B,MAahD5B,GAAuB9F,uBAAY,SAAC1G,GACxCoO,GAAcpO,GACdqO,GAAwB3S,QAAUsE,IACjC,IAKGsO,GAAe9S,iBAAuB,MACtC+S,GAAuB/S,iBAAOmE,IAC9B0O,GAA0B7S,iBAAO2S,IACjCK,GAAqBhT,kBAAQ,GAxBmB,GClMjD,SAAyBqB,GAC9B,IAAM4R,EAAUjT,iBAAuB,MADkD,EAEvD4L,mBAAS,GAF8C,mBAElFsH,EAFkF,KAEvEC,EAFuE,KAmBzF,OAfAlT,2BAAgB,WAEd,GAAqB,kBAAVoB,EAQX,OAHA2H,IAEAY,OAAOC,iBAAiB,SAAUb,GAC3B,WACLY,OAAOG,oBAAoB,SAAUf,IARvC,SAASA,IAEPmK,EAAaF,EAAQ/S,QAASoJ,wBAAwBjI,UAQvD,CAACA,IAEG,CAAC4R,EAAS5R,GAAS6R,GD4MGE,CAAa/R,GA7BY,qBA6B/C4R,GA7B+C,MA8BhD9P,GA9BgD,MA8BpB,EAC5BkQ,GAAkBvB,EAAgB,EAAI,EACtCwB,QAAgCvR,IAAjBwP,QAAuDxP,IAAzBgJ,EAhCG,GAkCwB3F,EAAmB,CAC/FhB,QAASiB,EACT1B,iBACAT,gBACAoC,mBACAC,cACApC,mBANMiB,GAlC8C,GAkC9CA,QAASgD,GAlCqC,GAkCrCA,gBAAiBd,GAlCoB,GAkCpBA,iBAAkBT,GAlCE,GAkCFA,sBAS9C0N,GAAoBlC,GAAmBS,EAAgBR,EAAsB,GAC7EkC,GAAenR,EACjB,EACAkR,IACCjN,GAAmBnD,GAAgBrB,IAAqB,GA/CP,GbxLjD,SACLO,EACA6J,EACAG,EACAoH,GAEA,IACMC,EAAqBnQ,KAAKC,MAAM6I,EAAYH,GAC5CyH,EAAmBpQ,KAAKO,IAAI2P,EAAY,EAAGlQ,KAAKC,OAAO6I,EAAYhK,GAAU6J,IAInF,MAAO,CAHqB3I,KAAKM,IAAI,EAXZ,IAWeN,KAAKC,OAAOkQ,EAH1B,GARD,MAYCnQ,KAAKO,IAAI2P,EAAY,EAZtB,IAYyBlQ,KAAKqQ,MAAMD,EAJnC,GARD,Oa2OwBE,CAC/CL,GACAtH,EACAG,GACAhI,EAAKwC,QArD+C,qBAiD/CiN,GAjD+C,MAiD1BC,GAjD0B,MAoHtD,SAASC,GAAcnR,GACrB,GAAIkP,IAAuBhO,EAAkBlB,IAAUoR,GAAmB9P,IAAmB,CAE3F,IAAM+P,EAAerR,EAAM3B,IAAIiT,cAC/B,GAAqB,MAAjBD,EAEF,YA0DN,WAAuB,IACb3P,EAAgBJ,GAAhBI,IAAKC,EAAWL,GAAXK,OACPpF,EAAQiF,EAAKG,GAAQJ,GAAQG,GAAKrD,KACxCsR,GAAkB,CAAEjO,MAAKC,SAAQpF,UA9D7BgV,GAGF,GAAqB,MAAjBF,EAEF,YA4DN,WACE,GACqB,OAAnB3B,KACI8B,GAAelQ,KACfoO,GAAehO,MAAQJ,GAAiBI,KAAOgO,GAAe/N,SAAWL,GAAiBK,OAE9F,OANmB,IASL8P,EAAUnQ,GAAlBK,OAEFgK,EAAUpK,GAAQD,GAAiBI,KAAKrD,IAC9BqT,EAAwBhC,GAAhC/N,OAAiBD,EAAegO,GAAfhO,IAAKnF,EAAUmT,GAAVnT,MACxBoV,EAAcpQ,GAAQG,GAAKrD,IAErB,OAAZkQ,QAAY,IAAZA,KAAe,CACb5C,UACA+F,UACAD,QACAlG,QAAQ,eAAII,EAAUpP,GACtBqV,OAAQvV,EAAcwV,WACtBF,gBAlFEG,GAKJ,OAAQ9R,EAAM3B,KACZ,IAAK,SAEH,YADAsR,GAAkB,MAEpB,IAAK,UACL,IAAK,YACL,IAAK,YACL,IAAK,aACL,IAAK,MACL,IAAK,OACL,IAAK,MACL,IAAK,SACL,IAAK,YA8NT,SAAkB3P,GAA6C,IACrD3B,EAAkB2B,EAAlB3B,IAAKL,EAAagC,EAAbhC,SACPmD,EAAUD,EAAkBlB,GAC9B+R,EAhCN,SAAyB1T,EAAa8C,EAAkBnD,GAA8B,IAC5E0D,EAAgBJ,GAAhBI,IAAKC,EAAWL,GAAXK,OACb,OAAQtD,GACN,IAAK,UACH,MAAO,CAAEqD,MAAKC,OAAQA,EAAS,GACjC,IAAK,YACH,MAAO,CAAED,MAAKC,OAAQA,EAAS,GACjC,IAAK,YACH,MAAO,CAAED,IAAKA,EAAM,EAAGC,UACzB,IAAK,aACH,MAAO,CAAED,IAAKA,EAAM,EAAGC,UACzB,IAAK,MACH,OAA8B,IAA1BL,GAAiBI,MAA2C,IAA7BJ,GAAiBK,OAC3C3D,EAAW,CAAE0D,IAAKH,GAAQyC,OAAS,EAAGrC,OAAQH,EAAKwC,OAAS,GAAM,CAAEtC,IAAK,EAAGC,OAAQ,GAEtF,CAAED,IAAKA,GAAO1D,GAAY,EAAI,GAAI2D,UAC3C,IAAK,OACH,OAAOR,EAAU,CAAEO,IAAK,EAAGC,OAAQ,GAAM,CAAED,IAAK,EAAGC,UACrD,IAAK,MACH,OAAOR,EAAU,CAAEO,IAAKH,GAAQyC,OAAS,EAAGrC,OAAQH,EAAKwC,OAAS,GAAM,CAAEtC,IAAKH,GAAQyC,OAAS,EAAGrC,UACrG,IAAK,SACH,MAAO,CAAED,MAAKC,OAAQA,EAASjB,KAAKC,MAAMgQ,GAAetH,IAC3D,IAAK,WACH,MAAO,CAAE3H,MAAKC,OAAQA,EAASjB,KAAKC,MAAMgQ,GAAetH,IAC3D,QACE,OAAO/H,IAOQ0Q,CAAgB3T,EAAK8C,EAASnD,GAC7C2O,EAAOyC,GACX,GAAY,QAAR/Q,EAAe,CAEjB,GjB3eC,YAA+I,IAArH+Q,EAAoH,EAApHA,mBAAoB7N,EAAgG,EAAhGA,QAASqP,EAAuF,EAAvFA,UAAuF,IAA5EtP,iBAAoBK,EAAwD,EAAxDA,OAAQD,EAAgD,EAAhDA,IAAO1D,EAAyC,EAAzCA,SAG1G,GAAIoR,IAAuBhT,EAAmBqJ,MAAQ2J,IAAuBhT,EAAmB6V,WAAY,CAC1G,IAAMC,EAAkBxQ,IAAQH,EAAQyC,OAAS,EAKjD,OAAOhG,EAJ0B,IAAR0D,GAEK,IAAXC,EAEgCuQ,GAHjCvQ,IAAWiP,EAAY,EAM3C,OAAO,EiB+dCuB,CAAY,CAAEnU,WAAUoR,sBAAoB7N,WAASqP,UAAWpP,EAAKwC,OAAQ1C,sBAE/E,OAGFqL,EAAOyC,KAAuBhT,EAAmBqJ,KAC7CrJ,EAAmB6V,WACnB7C,GAINpP,EAAMD,iBASN8M,GAPAkF,EjB3iBG,YAAiJ,IAAvG3C,EAAsG,EAAtGA,mBAAoB7N,EAAkF,EAAlFA,QAASqP,EAAyE,EAAzEA,UAAWmB,EAA8D,EAA9DA,aACvF,GAAI3C,IAAuBhT,EAAmBqJ,KAAM,CAAC,IAC3C/D,EAAgBqQ,EAAhBrQ,IAAKC,EAAWoQ,EAAXpQ,OACPyQ,EAAe7Q,EAAQyC,OAEvBqO,GAA+B,IAAT3Q,EAE5B,GAH0BA,IAAQ0Q,GAIhC,GAAIhD,IAAuBhT,EAAmB6V,YAE5C,KADkBtQ,IAAWiP,EAAY,GAEvC,MAAO,CACLlP,IAAK,EACLC,OAAQA,EAAS,QAGhB,GAAIyN,IAAuBhT,EAAmBkW,cACnD,MAAO,CACL3Q,SACAD,IAAK,QAGJ,GAAI2Q,EAAqB,CAC9B,GAAIjD,IAAuBhT,EAAmB6V,YAE5C,KAD8B,IAAXtQ,GAEjB,MAAO,CACLA,OAAQA,EAAS,EACjBD,IAAK0Q,EAAe,QAGnB,GAAIhD,IAAuBhT,EAAmBkW,cACnD,MAAO,CACL3Q,SACAD,IAAK0Q,EAAe,IAM5B,OAAOL,EiBmgBUQ,CAA+B,CAC5ChR,WACAqP,UAAWpP,EAAKwC,OAChBoL,mBAAoBzC,EACpBoF,kBArPES,CAASxS,GACT,MACF,QACMoR,GAAmB9P,KAiE7B,SAAyBtB,GAA6C,IAC5D3B,EAAQ2B,EAAR3B,IACwC,WAA1BiD,GAAiBqL,MAAqB6E,GAAelQ,KAE7C,UAARjD,GACpBoR,IAAoB,kBAAsB,CAAE/N,IAAxB,EAAGA,IAA0BC,OAA7B,EAAQA,OAA6BtD,MAAKsO,KAAM,WArEhE8F,CAAgBzS,IAxFxB5C,2BAAgB,WAAO,IAAD,EAChBkE,KAAqB4O,GAAqB7S,SAAqC,SAA1BiE,GAAiBqL,MAAoByE,GAAmB9P,MACjH4O,GAAqB7S,QAAUiE,GAC/BoR,GAAapR,KAEb,UADeC,GAAQD,GAAiBI,KAC7BiR,wBAAX,aAAI,EAAyBC,YAC7B3C,GAAa5S,QAASC,YAGxB+M,qBAAU,WACR,GAAKnC,EAAL,CAyBA,OAAOkE,GAASyG,UAAU,cAvBO,SAAC,GAAuD,IAArDlR,EAAoD,EAApDA,OAAQ7D,EAA4C,EAA5CA,QAASkP,EAAmC,EAAnCA,aACnDhL,EAAiBiG,GACjB,IAAMK,EAAkB,IAAItD,IAAI0J,GAC1BoE,EAAQtR,EAAKG,GAAQsG,GAE3B,GAAInK,EAAS,CACXwK,EAAgBpD,IAAI4N,GACpB,IAAMC,EAAiB5C,GAAmB9S,QAE1C,GADA8S,GAAmB9S,QAAUsE,EACzBqL,IAAoC,IAApB+F,GAAyBA,IAAmBpR,EAE9D,IADA,IAAMqR,EAAOtS,KAAKuS,KAAKtR,EAASoR,GACvBG,EAAIH,EAAiBC,EAAME,IAAMvR,EAAQuR,GAAKF,EACrD1K,EAAgBpD,IAAI1D,EAAK0R,GAAGjL,SAIhCK,EAAgBnD,OAAO2N,GACvB3C,GAAmB9S,SAAW,EAGhC6K,EAAqBI,SAItB,CAAC8D,GAAUlE,EAAsB1G,EAAMyG,EAAQyG,IAElDrE,qBAAU,WACR,OAAO+B,GAASyG,UAAU,cAAehG,OAG3CsG,8BAAoBzV,GAAK,iBAAO,CAC9B0V,eAD8B,SACf1R,GACbgR,GAAa,CAAEhR,SAEjB2R,YAJ8B,SAIlB1R,GAAiB,IACnBtE,EAAY+S,GAAZ/S,QACHA,IACLA,EAAQmM,UAAY7H,EAAS0H,IAE/BwD,kBAkDF,IAAMyG,GAAqBjL,uBAAY,SAACjK,EAA6BI,GACnE,IAAM+U,EAAkB,IAAI3O,IAAIvE,IAChCkT,EAAgBxO,IAAI3G,EAAOC,IAAKG,GAChCgR,GAAgB+D,GAEF,OAAdpL,QAAc,IAAdA,KAAiB/J,EAAOsD,IAAKlD,KAC5B,CAAC6B,GAAc8H,IAElB,SAASqL,GAAT,GAAkE,IAA1C7H,EAAyC,EAAzCA,QAAShK,EAAgC,EAAhCA,OAAQ4J,EAAwB,EAAxBA,QAC3B,OAAZgD,QAAY,IAAZA,KAAe,CACb5C,UACA+F,QAAS/P,EACT8P,MAAO9P,EACP4J,UACAqG,OAAQvV,EAAcoX,cAGxBC,KA8DF,SAASC,GAAgB3T,GAMvB,SAAS4T,EAAY5T,GAIG,IAAlBA,EAAM6T,SAAe5M,IAG3B,SAASA,IACPF,OAAOG,oBAAoB,YAAa0M,GACxC7M,OAAOG,oBAAoB,UAAWD,GACtC4I,IAAY,GAnChB,WACE,QAAwC3Q,IAApC8Q,GAAwB3S,QAA5B,CADuB,IAGfqE,EAAgBJ,GAAhBI,IAAKC,EAAWL,GAAXK,OAEPgK,EADSpK,GAAQG,GACArD,IACjB9B,EAAQiF,EAAKG,GAAQgK,GAEf,OAAZ4C,QAAY,IAAZA,KAAe,CACb5C,UACA+F,QAAS/P,EACT8P,MAAOzB,GAAwB3S,QAC/BkO,QAAQ,eAAII,EAAUpP,GACtBqV,OAAQvV,EAAcyX,YAGxB3F,QAAqBjP,IAoBnB6U,GAhBoB,IAAlB/T,EAAM6T,UACVhE,IAAY,GACZ9I,OAAOC,iBAAiB,YAAa4M,GACrC7M,OAAOC,iBAAiB,UAAWC,IAiBrC,SAAS+M,GAAkBhU,GACzBA,EAAM+L,kBAEN,IACMJ,EADSpK,GAAQD,GAAiBI,KACjBrD,IACjB9B,EAAQiF,EAAKF,GAAiBK,QAAQgK,GAEhC,OAAZ4C,QAAY,IAAZA,KAAe,CACb5C,UACA+F,QAASpQ,GAAiBK,OAC1B8P,MAAOjQ,EAAKwC,OAAS,EACrBuH,QAAQ,eAAII,EAAUpP,GACtBqV,OAAQvV,EAAc4X,cAO1B,SAAS7C,GAAT,GAAiE,IAAnC1P,EAAkC,EAAlCA,IAAKC,EAA6B,EAA7BA,OACjC,OAAOA,GAAU,GAAKA,EAASH,EAAKwC,QAAUtC,GAAO,GAAKA,EAAMH,GAAQyC,OAG1E,SAASwN,GAAelS,GACtB,OAAO8R,GAAmB9R,IACrB+B,EAA0B,CAAEE,WAASC,OAAMF,iBAAkBhC,EAAUmC,0BAG9E,SAASoL,GAAWvN,GAAiD,IAA7B4U,EAA4B,wDAC7D9C,GAAmB9R,KAEpB4U,GAAgB1C,GAAelS,GACjCmQ,GAAoB,2BAAKnQ,GAAN,IAAgBqN,KAAM,OAAQtO,IAAK,QAEtDoR,GAAoB,2BAAKnQ,GAAN,IAAgBqN,KAAM,YAEvB,OAApBqC,QAAoB,IAApBA,KAAoB,eAAQ1P,KAG9B,SAASoU,KACPjE,IAAoB,kBAAsB,CAAE/N,IAAxB,EAAGA,IAA0BC,OAA7B,EAAQA,OAA6BgL,KAAM,aASjE,SAAS+F,GAAT,GAAiE,IAAzChR,EAAwC,EAAxCA,IAAKC,EAAmC,EAAnCA,OACnBtE,EAAY+S,GAAZ/S,QACR,GAAKA,EAAL,CAEA,GAAmB,kBAARqE,GAAoBA,EAAMsB,GAAuB,CAAC,IACnDnD,EAAgBxC,EAAhBwC,YADkD,EAElC0B,GAAQG,GAAxBkB,EAFkD,EAElDA,KAAMpE,EAF4C,EAE5CA,MAGd,GAF6BoE,EAAOF,GAAalE,EAbrD,WACE,IAA+B,IAA3BwE,GAA8B,OAAO,EACzC,IAAMmR,EAAgB5S,GAAQyB,IAC9B,OAAOmR,EAAcvR,KAAOuR,EAAc3V,MAUiB4V,IAC3BxR,EAAOpE,EAAQqB,EAAc6C,GACR,CACjD,IAAM2R,EnBlZP,SAAoC9S,EAAyCG,EAAa4S,EAA2BC,GAI1H,IAHA,IAAI3R,EAAO,EAGFsQ,EAAI,EAAGA,EAAIxR,EAAKwR,IAAK,CAC5B,IAAM9U,EAASmD,EAAQ2R,GACnB9U,GACEA,EAAOI,QACToE,GAAQxE,EAAOI,OAKrB,IAAMgW,EAAiBjT,EAAQG,GAC/B,GAAI8S,EAAgB,CAClB,IAAM9R,EAAaE,EAbR,EAawB0R,EAC7BG,EAAc7R,EAAO4R,EAAehW,MAAQ8V,EAElD,GAAI5R,EAAa,EACf,OAAOA,EAET,GAAI+R,EAAcF,EAChB,OAAOE,EAAcF,EAIzB,OAAO,EmBwXqBG,CAAwBnT,GAASG,EAAKgB,GAAY7C,GACxExC,EAAQqF,WAAaA,GAAa2R,GAIhB,kBAAX1S,IACLA,EAAS0H,EAAYG,GAEvBnM,EAAQmM,UAAY7H,EAAS0H,GACnB1H,EAAS,GAAK0H,EAAYG,GAAYmH,KAEhDtT,EAAQmM,WAAa7H,EAAS,GAAK0H,EAAYsH,MAgErD,SAASgE,GAAsBC,GAC7B,QAA0B1V,IAAtB4Q,GAAJ,CADwE,IAEhEnO,EAAWL,GAAXK,OAMR,OAJsBA,EAASmO,GAC3BnO,EAASiT,GAAiBA,GAAiB9E,GAC3CnO,EAASiT,GAAiBA,GAAiB9E,IAExBxO,GAAiBI,SAAMxC,GAGhD,SAAS2V,GAAqBlT,GAC5B,GAAIL,GAAiBK,SAAWA,EAEhC,MAA8B,SAA1BL,GAAiBqL,KACZ,CACLA,KAAM,OACNjL,IAAKJ,GAAiBI,IACtBoK,UAAWqF,GACXjE,qBAAsB,CACpBC,sBACA9D,YACA3G,cACA8G,aACAE,oBAAqBpI,GAAiBjD,IACtCiL,SAAUkK,GACVjK,eAAgBmK,KAKf,CACL/G,KAAM,SACNjL,IAAKJ,GAAiBI,IACtBoK,UAAWqF,GACXxD,gBAAiBwB,IAAyBqC,GAAelQ,IACrD,CAAE+E,YAAasN,GAAiBpH,cAAeyH,SAC/C9U,GAiDR,OANIoC,GAAiBI,KAAOH,GAAQyC,QAAU1C,GAAiBK,QAAUH,EAAKwC,UAC5EyL,GAAoB,CAAE/N,KAAM,EAAGC,QAAS,EAAGgL,KAAM,WACjDgD,GAAkB,MAClBxB,QAAqBjP,IAIrB,yBACE0I,KAAK,OACLpK,aAAYR,GACZS,kBAAiBR,GACjB6X,mBAAkBzF,GAClB0F,yBAAsBtE,SAAsBvR,EAC5C8V,gBAAezT,GAAQyC,OACvBiR,gBAAezE,GAAkBhP,EAAKwC,OACtCxH,UAAWe,YAAK,MAAO,CAAE,wBAAyBqS,KAClDnT,MAAO,CACL+B,QACAgB,SACA,sBAAsB,GAAtB,OAA0BgP,EAA1B,MACA,sBAAsB,GAAtB,OAA0BC,EAA1B,MACA,iBAAiB,GAAjB,OAAqBhL,GAArB,MACA,eAAe,GAAf,OAAmB4F,EAAnB,OAEF3L,IAAK0S,GACLrB,SA1VJ,SAAsB/O,GAAuC,IAAD,EACxBA,EAAMuG,cAAhCiD,EADkD,EAClDA,UAAW9G,EADuC,EACvCA,WACnB4M,GAAa9F,GACb+F,GAAc7M,GACN,OAARqM,QAAQ,IAARA,KAAW/O,KAwVT,kBAAC,EAAD,CACEiI,OAAQA,EACRzG,KAAMA,EACND,QAASgD,GACT4D,eAAgBmL,GAChBtQ,sBAAuBA,GACvBrE,iBAA6B,OAAZ+P,QAAY,IAAZA,OAAA,EAAAA,EAAc1P,QAASwC,EAAKwC,OAC7CkE,qBAAsBA,EACtBtC,WAAYA,EACZC,cAAeA,EACfF,OAAQA,IAETsJ,GACC,kBAAC,EAAD,CACEjM,sBAAuBA,GACvBzB,QAASgD,GACTiE,QAASA,EACTC,gBAAiBA,IAGJ,IAAhBjH,EAAKwC,QAAgB8K,EAAoBzP,wBAAcyP,GACtD,oCACE,yBACEpR,IAAKuS,GACLrT,SAAU,EACVJ,UAAU,iBACVsP,UAAWqF,KAEb,yBAAK1U,MAAO,CAAE+C,OAAQkB,KAAKM,IAAIQ,EAAKwC,OAASqF,EAAWsH,OA9FhE,WAEE,IADA,IAAMuE,EAAc,GACXvT,EAASsP,GAAqBtP,GAAUuP,GAAmBvP,IAAU,CAC5E,IAAMxD,EAAMqD,EAAKG,GACbtD,EAAuBsD,EACvB7C,GAAgB,EACpB,QAAeI,IAAX+I,EAAsB,CAAC,IAAD,EAClB6K,EAAQ3U,EAAI8J,GAClBnJ,EAAa,iBAAG4P,QAAH,IAAGA,OAAH,EAAGA,EAAcnO,IAAIuS,UAArB,SACQ,kBAAVA,GAAuC,kBAAVA,IACtCzU,EAAMyU,GAGVoC,EAAY9R,KACV,kBAACwL,EAAD,CACErG,gBAAeiI,GAAkB7O,EAAS,EAC1CsL,gBAAewD,GAAe3R,OAAgBI,EAC9Cb,IAAKA,EACLsD,OAAQA,EACRxD,IAAKA,EACLoG,gBAAiBA,GACjBvB,sBAAuBA,GACvBoJ,SAAUA,GACVtN,cAAeA,EACfwN,WAAYA,EACZ4B,SAAUA,GACV3O,IAAKoC,EAAS0H,EAAYqH,GAC1B1C,eAA6B,OAAd0B,SAAc,IAAdA,QAAA,EAAAA,GAAgB/N,UAAWA,EAAS+N,GAAehO,SAAMxC,EACxE+O,mBAAoB0G,GAAsBhT,GAC1CwM,qBAAsByB,GAAazB,QAAuBjP,EAC1DmN,kBAAmBwI,GAAqBlT,MAK9C,OAAOuT,EA4DAC,Q,6BEnsBX,SAASC,GAAwBC,GAC/B,MAAO,CACLC,GAAG,MAAD,OAAQD,GACVE,OAAQC,KAAMC,MAAMF,SACpBG,QAAQ,GAAD,OAAKF,KAAMjX,KAAKoX,YAAhB,YAA+BH,KAAMjX,KAAKqX,YACjDC,WAAanV,KAAKC,MAAsB,IAAhBD,KAAKoV,UAAoBC,WACjDC,SAAUR,KAAMS,QAAQC,OAAS,KAAOV,KAAMS,QAAQE,QAAU,KAAOX,KAAMS,QAAQG,UACrFC,MAAO3V,KAAKC,MAAsB,GAAhBD,KAAKoV,UACvBQ,KAAMd,KAAMe,MAAMC,SAYtB,SAASC,GAAWzW,GAClB,IAAMnC,EAASmC,EAAMnC,OACrB,OAAOA,EAAO8S,aAAe9S,EAAO2L,YAAc3L,EAAO6Y,aAG3D,SAASC,GAAaC,EAAsB5S,GAC1C,OAAO,IAAI6S,SAAQ,SAAAC,GAEjB,IADA,IAAMC,EAAiB,GACd7D,EAAI,EAAGA,EAAI0D,EAAc1D,IAChC6D,EAAQ7D,GAAKkC,GAAwBlC,EAAIlP,GAE3CgT,YAAW,kBAAMF,EAAQC,KAAU,QAIxB,SAASE,KAAY,IAAD,EACTlO,mBAxB1B,SAAoBmO,GAElB,IADA,IAAM1V,EAAc,GACX0R,EAAI,EAAGA,EAAIgE,EAAchE,IAChC1R,EAAK0R,GAAKkC,GAAwBlC,GAEpC,OAAO1R,EAmBiC2V,CAAW,MADlB,mBAC1B3V,EAD0B,KACpB4V,EADoB,OAEOrO,oBAAS,kBAAM,IAAI/D,OAF1B,mBAE1B0J,EAF0B,KAEZ2I,EAFY,OAGCtO,oBAAS,GAHV,mBAG1BuO,EAH0B,KAGfC,EAHe,KAI3BnH,EAAUjT,iBAAuB,MAEjCoE,EAAUe,mBAAQ,iBAAqB,CAC3ChE,EAMA,CACED,IAAK,SACLE,KAAM,UACNC,MAAO,GACPK,UAAW,gBAAGV,EAAH,EAAGA,IAAH,OAAa,kBAAC7B,EAAD,CAAgBC,MAAO4B,EAAIoX,WAErD,CACElX,IAAK,UACLE,KAAM,GACNC,MAAO,KAET,CACEH,IAAK,aACLE,KAAM,cACNC,MAAO,KAET,CACEH,IAAK,WACLE,KAAM,WACNC,MAAO,KAET,CACEH,IAAK,QACLE,KAAM,QACNC,MAAO,IAET,CACEH,IAAK,OACLE,KAAM,WAEP,IAEGiZ,EAAkBnP,uBAAY,YAA+E,IAE7GoP,EACAC,EAHiChG,EAA2E,EAA3EA,QAASD,EAAkE,EAAlEA,MAAOlG,EAA2D,EAA3DA,QAASqG,EAAkD,EAAlDA,OACxDmF,EAAO,YAAOvV,GAIhBoQ,IAAWvV,EAAcwV,YAC3B4F,EAAQhG,EACRiG,EAAMjG,IAENgG,EAAQ/W,KAAKO,IAAIyQ,EAASD,GAC1BiG,EAAMhX,KAAKM,IAAI0Q,EAASD,IAG1B,IAAK,IAAIyB,EAAIuE,EAAOvE,GAAKwE,EAAKxE,IAC5B6D,EAAQ7D,GAAR,2BAAkB6D,EAAQ7D,IAAO3H,GAGnC6L,EAAQL,KACP,CAACvV,IAEEmW,EAAiBtP,uBAAY,SAAC1G,EAAgBxD,EAAUC,GAC/B,IAAD,EAAT,UAAfA,EAAOC,MACT,UAAA+R,EAAQ/S,eAAR,SAAiBwP,WAAW,CAAElL,SAAQD,IAAKtD,EAAOsD,MAAO,MAE1D,IArE8B,SAuElBkW,EAvEkB,8EAuEjC,WAA4B5X,GAA5B,eAAA6X,EAAA,yDACOpB,GAAWzW,GADlB,wDAGEuX,GAAa,GAHf,SAKwBZ,GAAa,GAAInV,EAAKwC,QAL9C,OAKQ+S,EALR,OAOEK,EAAQ,GAAD,mBAAK5V,GAAL,YAAcuV,KACrBQ,GAAa,GARf,4CAvEiC,sBAkFjC,OACE,oCACE,kBAAC,IAAD,MACG,gBAAG/X,EAAH,EAAGA,OAAQhB,EAAX,EAAWA,MAAX,OACC,oCACE,kBAAC,EAAD,CACEd,IAAK0S,EACL7O,QAASA,EACTC,KAAMA,EACNyG,OAAO,KACPsG,aAAciJ,EACdlL,WAAYqL,EACZtO,UAAW,GACX7K,MAAOA,EACPgB,OAAQA,EAAS,GACjBkP,aAAcA,EACdK,SAAU6I,EACV1P,qBAAsBmP,EACtBnJ,SAAU,SAAA/P,GAAG,OAAIA,EAAImX,GAAGlK,SAAS,KAAO,iBAAclM,GACtDgQ,qBAAmB,EACnBC,uBAAqB,IAEtBmI,GAAa,yBAAK9a,UAAU,sBAAf,6BC3JX,SAASsb,KACtB,OAAO,kBAACb,GAAD","file":"static/js/4.47a354a4.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/rdg-image.98a63106.less\";","export enum CellNavigationMode {\n  NONE = 'none',\n  CHANGE_ROW = 'changeRow',\n  LOOP_OVER_ROW = 'loopOverRow'\n}\n\nexport enum UpdateActions {\n  CELL_UPDATE = 'CELL_UPDATE',\n  COLUMN_FILL = 'COLUMN_FILL',\n  COPY_PASTE = 'COPY_PASTE',\n  CELL_DRAG = 'CELL_DRAG'\n}\n\nexport type SortDirection = 'ASC' | 'DESC' | 'NONE';\n","import React from 'react';\nimport '../../style/rdg-image.less';\n\ninterface Props {\n  /** image url, used as background-image */\n  value: string;\n}\n\nexport function ImageFormatter({ value }: Props) {\n  return (\n    <div className=\"rdg-image-cell-wrapper\">\n      <div className=\"rdg-image-cell\" style={{ backgroundImage: `url(${value})` }} />\n    </div>\n  );\n}\n","import React, { useLayoutEffect, useRef } from 'react';\nimport clsx from 'clsx';\n\ntype SharedInputProps = Pick<React.InputHTMLAttributes<HTMLInputElement>,\n  | 'disabled'\n  | 'tabIndex'\n  | 'aria-label'\n  | 'aria-labelledby'\n>;\n\nexport interface SelectCellFormatterProps extends SharedInputProps {\n  isCellSelected?: boolean;\n  value: boolean;\n  onChange: (value: boolean, isShiftClick: boolean) => void;\n}\n\nexport function SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}: SelectCellFormatterProps) {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useLayoutEffect(() => {\n    if (!isCellSelected) return;\n    inputRef.current?.focus();\n  }, [isCellSelected]);\n\n  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {\n    onChange(e.target.checked, (e.nativeEvent as MouseEvent).shiftKey);\n  }\n\n  return (\n    <label className={clsx('rdg-checkbox-label', { 'rdg-checkbox-label-disabled': disabled })}>\n      <input\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        tabIndex={tabIndex}\n        ref={inputRef}\n        type=\"checkbox\"\n        className=\"rdg-checkbox-input\"\n        disabled={disabled}\n        onChange={handleChange}\n        checked={value}\n      />\n      <div className=\"rdg-checkbox\" />\n    </label>\n  );\n}\n","import React from 'react';\nimport { FormatterProps } from '../types';\n\nexport function ValueFormatter<R>(props: FormatterProps<R>) {\n  return <>{props.row[props.column.key as keyof R]}</>;\n}\n","import React from 'react';\nimport { SelectCellFormatter } from './formatters';\nimport { Column } from './types';\n\n// TODO: fix type\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const SelectColumn: Column<any> = {\n  key: 'select-row',\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  headerRenderer(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select All\"\n        value={props.allRowsSelected}\n        onChange={props.onAllRowsSelectionChange}\n      />\n    );\n  },\n  formatter(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select\"\n        tabIndex={-1}\n        isCellSelected={props.isCellSelected}\n        value={props.isRowSelected}\n        onChange={props.onRowSelectionChange}\n      />\n    );\n  }\n};\n","let size: number | undefined;\n\nexport function getScrollbarSize(): number {\n  if (size === undefined) {\n    const scrollDiv = document.createElement('div');\n\n    scrollDiv.style.position = 'absolute';\n    scrollDiv.style.top = '-9999px';\n    scrollDiv.style.width = '50px';\n    scrollDiv.style.height = '50px';\n    scrollDiv.style.overflow = 'scroll';\n\n    document.body.appendChild(scrollDiv);\n    size = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n  }\n\n  return size;\n}\n\nexport function preventDefault(event: React.SyntheticEvent) {\n  event.preventDefault();\n}\n\nexport function wrapEvent<E extends React.SyntheticEvent>(ourHandler: React.EventHandler<E>, theirHandler: React.EventHandler<E> | undefined) {\n  if (theirHandler === undefined) return ourHandler;\n\n  return function(event: E) {\n    ourHandler(event);\n    theirHandler(event);\n  };\n}\n","import { Column, CalculatedColumn, FormatterProps, Omit } from '../types';\nimport { getScrollbarSize } from './domUtils';\n\ninterface Metrics<R> {\n  columns: readonly Column<R>[];\n  columnWidths: ReadonlyMap<string, number>;\n  minColumnWidth: number;\n  viewportWidth: number;\n  defaultFormatter: React.ComponentType<FormatterProps<R>>;\n}\n\ninterface ColumnMetrics<TRow> {\n  columns: readonly CalculatedColumn<TRow>[];\n  lastFrozenColumnIndex: number;\n  totalColumnWidth: number;\n}\n\nexport function getColumnMetrics<R>(metrics: Metrics<R>): ColumnMetrics<R> {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  const columns: Array<Omit<Column<R>, 'width'> & { width: number | undefined }> = [];\n\n  for (const metricsColumn of metrics.columns) {\n    let width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth );\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    const column = { ...metricsColumn, width };\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n      columns.splice(lastFrozenColumnIndex, 0, column);\n    } else {\n      columns.push(column);\n    }\n  }\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  const unallocatedColumnWidth = Math.max(\n    Math.floor(unallocatedWidth / unassignedColumnsCount),\n    metrics.minColumnWidth\n  );\n\n  const calculatedColumns: CalculatedColumn<R>[] = columns.map((column, idx) => {\n    // Every column should have a valid width at this stage\n    const width = column.width ?? clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n    const newColumn = {\n      ...column,\n      idx,\n      width,\n      left,\n      formatter: column.formatter ?? metrics.defaultFormatter\n    };\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth\n  };\n}\n\nfunction getSpecifiedWidth<R>(\n  { key, width }: Column<R>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R>(\n  width: number,\n  { minWidth, maxWidth }: Column<R>,\n  minColumnWidth: number\n): number {\n  width = Math.max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n\n// Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\nexport function canEdit<R>(column: CalculatedColumn<R>, row: R): boolean {\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n  return Boolean(column.editor || column.editable);\n}\n\nexport function getColumnScrollPosition<R>(columns: readonly CalculatedColumn<R>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n","export function isKeyPrintable(keycode: number): boolean {\n  return (keycode > 47 && keycode < 58) // number keys\n    || keycode === 32 || keycode === 13 // spacebar & return key(s) (if you want to allow carriage returns)\n    || (keycode > 64 && keycode < 91) // letter keys\n    || (keycode > 95 && keycode < 112) // numpad keys\n    || (keycode > 185 && keycode < 193) // ;=,-./` (in order)\n    || (keycode > 218 && keycode < 223); // [\\]' (in order)\n}\n\nexport function isCtrlKeyHeldDown(e: React.KeyboardEvent): boolean {\n  return (e.ctrlKey === true || e.metaKey === true) && e.key !== 'Control';\n}\n","import { CellNavigationMode } from '../enums';\nimport { canEdit } from './columnUtils';\nimport { CalculatedColumn, Position } from '../types';\n\ninterface IsSelectedCellEditableOpts<R> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R>[];\n  rows: readonly R[];\n  onCheckCellIsEditable?: (arg: { row: R; column: CalculatedColumn<R> } & Position) => boolean;\n}\n\nexport function isSelectedCellEditable<R>({ selectedPosition, columns, rows, onCheckCellIsEditable }: IsSelectedCellEditableOpts<R>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({ row, column, ...selectedPosition }) : true;\n  return isCellEditable && canEdit<R>(column, row);\n}\n\ninterface GetNextSelectedCellPositionOpts<R> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport function getNextSelectedCellPosition<R>({ cellNavigationMode, columns, rowsCount, nextPosition }: GetNextSelectedCellPositionOpts<R>): Position {\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\ninterface CanExitGridOpts<R> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R>[];\n  rowsCount: number;\n  selectedPosition: Position;\n  shiftKey: boolean;\n}\n\nexport function canExitGrid<R>({ cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx }, shiftKey }: CanExitGridOpts<R>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n","export * from './domUtils';\nexport * from './columnUtils';\nexport * from './viewportUtils';\nexport * from './keyboardUtils';\nexport * from './selectedCellUtils';\n\nexport function assertIsValidKey<R>(key: unknown): asserts key is keyof R {\n  if (key === undefined) {\n    throw new Error('Please specify the rowKey prop to use selection');\n  }\n}\n\nexport function wrapRefs<T>(...refs: readonly React.Ref<T>[]) {\n  return (handle: T | null) => {\n    for (let ref of refs) {\n      if (typeof ref === 'function') {\n        ref(handle);\n      } else if (ref !== null) {\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065\n        // @ts-expect-error\n        ref = {...ref, current: handle};\n      }\n    }\n  };\n}","import { useMemo } from 'react';\nimport { wrapRefs } from '../utils';\n\nexport function useCombinedRefs<T>(...refs: readonly React.Ref<T>[]) {\n  return useMemo(\n    () => wrapRefs<T>(...refs),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\n","import { useMemo } from 'react';\nimport { CalculatedColumn } from '../types';\nimport { getColumnMetrics, getHorizontalRangeToRender, getViewportColumns } from '../utils';\nimport { DataGridProps } from '../DataGrid';\n\ntype SharedDataGridProps<R, K extends keyof R> =\n  Pick<DataGridProps<R, K>, 'columns'> &\n  Required<Required<Pick<DataGridProps<R, K>, | 'minColumnWidth' | 'defaultFormatter' >>>;\n\ninterface ViewportColumnsArgs<R, K extends keyof R> extends SharedDataGridProps<R, K> {\n  viewportWidth: number;\n  scrollLeft: number;\n  columnWidths: ReadonlyMap<string, number>;\n}\n\nexport function useViewportColumns<R, K extends keyof R>({\n  columns: rawColumns,\n  minColumnWidth,\n  columnWidths,\n  viewportWidth,\n  defaultFormatter,\n  scrollLeft\n}: ViewportColumnsArgs<R, K>) {\n  const { columns, lastFrozenColumnIndex, totalColumnWidth } = useMemo(() => {\n    return getColumnMetrics<R>({\n      columns: rawColumns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultFormatter\n    });\n  }, [columnWidths, rawColumns, defaultFormatter, minColumnWidth, viewportWidth]);\n  \n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    return getHorizontalRangeToRender(\n      columns,\n      lastFrozenColumnIndex,\n      viewportWidth,\n      scrollLeft\n    );\n  }, [scrollLeft, columns, lastFrozenColumnIndex, viewportWidth]);\n\n  const viewportColumns = useMemo((): readonly CalculatedColumn<R>[] => {\n    return getViewportColumns(\n      columns,\n      colOverscanStartIdx,\n      colOverscanEndIdx\n    );\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n\n  return { columns, viewportColumns, totalColumnWidth, lastFrozenColumnIndex };\n}\n","import { CalculatedColumn } from '../types';\n\nfunction getTotalFrozenColumnWidth<R>(columns: readonly CalculatedColumn<R>[], lastFrozenColumnIndex: number): number {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nconst RENDER_BACTCH_SIZE = 800;\n\nexport function getVerticalRangeToRender(\n  height: number,\n  rowHeight: number,\n  scrollTop: number,\n  rowsCount: number\n) {\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return [rowOverscanStartIdx, rowOverscanEndIdx] as const;\n}\n\nexport function getHorizontalRangeToRender<R>(\n  columns: readonly CalculatedColumn<R>[],\n  lastFrozenColumnIndex: number,\n  viewportWidth: number,\n  scrollLeft: number\n): [number, number] {\n  // get the viewport's left side and right side positions for non-frozen columns\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  const viewportRight = scrollLeft + viewportWidth;\n  // get first and last non-frozen column indexes\n  const lastColIdx = columns.length - 1;\n  const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n  // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n  if (viewportLeft >= viewportRight) {\n    return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n  }\n\n  // get the first visible non-frozen column index\n  let colVisibleStartIdx = firstUnfrozenColumnIdx;\n  while (colVisibleStartIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleStartIdx];\n    // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n    if (left + width > viewportLeft) {\n      break;\n    }\n    colVisibleStartIdx++;\n  }\n\n  // get the last visible non-frozen column index\n  let colVisibleEndIdx = colVisibleStartIdx;\n  while (colVisibleEndIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleEndIdx];\n    // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n    if (left + width >= viewportRight) {\n      break;\n    }\n    colVisibleEndIdx++;\n  }\n\n  const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n  return [colOverscanStartIdx, colOverscanEndIdx];\n}\n\nexport function getViewportColumns<R>(columns: readonly CalculatedColumn<R>[], colOverscanStartIdx: number, colOverscanEndIdx: number) {\n  const viewportColumns: CalculatedColumn<R>[] = [];\n  for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n    const column = columns[colIdx];\n\n    if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n    viewportColumns.push(column);\n  }\n\n  return viewportColumns;\n}\n","import { Position, SelectRowEvent } from './types';\n\ninterface EventMap {\n  SELECT_CELL: (position: Position, openEditor?: boolean) => void;\n  SELECT_ROW: (event: SelectRowEvent) => void;\n}\n\ntype EventName = keyof EventMap;\n\nexport default class EventBus {\n  private readonly subscribers = new Map<EventName, Set<EventMap[EventName]>>();\n\n  subscribe<T extends EventName>(type: T, handler: EventMap[T]) {\n    if (!this.subscribers.has(type)) {\n      this.subscribers.set(type, new Set());\n    }\n\n    const handlers = this.subscribers.get(type)!;\n    handlers.add(handler);\n\n    return () => {\n      handlers.delete(handler);\n    };\n  }\n\n  dispatch<T extends EventName>(type: T, ...args: Parameters<EventMap[T]>) {\n    const handlers = this.subscribers.get(type);\n    if (handlers) {\n      // handler needed a type assertion to fix type bug\n      handlers.forEach(handler => {\n        (handler as (...args: Parameters<EventMap[T]>) => void)(...args);\n      });\n    }\n  }\n}\n","import React from 'react';\nimport { HeaderCellProps } from '../HeaderCell';\nimport { SortDirection } from '../enums';\n\nconst SORT_TEXT = {\n  ASC: '\\u25B2',\n  DESC: '\\u25BC',\n  NONE: ''\n} as const;\n\ntype SharedHeaderCellProps<R> = Pick<HeaderCellProps<R>,\n  | 'column'\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n>;\n\nexport interface Props<R> extends SharedHeaderCellProps<R> {\n  children: React.ReactNode;\n}\n\nexport default function SortableHeaderCell<R>({\n  column,\n  onSort,\n  sortColumn,\n  sortDirection,\n  children\n}: Props<R>) {\n  sortDirection = (sortColumn === column.key && sortDirection) || 'NONE';\n  function onClick() {\n    if (!onSort) return;\n    const sortDescendingFirst = column.sortDescendingFirst || false;\n    let direction: SortDirection;\n    switch (sortDirection) {\n      case 'ASC':\n        direction = sortDescendingFirst ? 'NONE' : 'DESC';\n        break;\n      case 'DESC':\n        direction = sortDescendingFirst ? 'ASC' : 'NONE';\n        break;\n      default:\n        direction = sortDescendingFirst ? 'DESC' : 'ASC';\n        break;\n    }\n    onSort(column.key, direction);\n  }\n\n  return (\n    <span className=\"rdg-header-sort-cell\" onClick={onClick}>\n      <span className=\"rdg-header-sort-name\">{children}</span>\n      <span>{SORT_TEXT[sortDirection]}</span>\n    </span>\n  );\n}\n","import React, { cloneElement } from 'react';\nimport { CalculatedColumn } from '../types';\n\nexport interface ResizableHeaderCellProps<R> {\n  children: React.ReactElement<React.ComponentProps<'div'>>;\n  column: CalculatedColumn<R>;\n  onResize: (column: CalculatedColumn<R>, width: number) => void;\n}\n\nexport default function ResizableHeaderCell<R>({\n  children,\n  column,\n  onResize\n}: ResizableHeaderCellProps<R>) {\n  function onMouseDown(event: React.MouseEvent) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const { currentTarget } = event;\n    const { right } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) { // +1px to account for the border size\n      return;\n    }\n\n    const onMouseMove = (event: MouseEvent) => {\n      handleResize(event.clientX + offset, currentTarget);\n    };\n\n    const onMouseUp = () => {\n      window.removeEventListener('mousemove', onMouseMove);\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    event.preventDefault();\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  }\n\n  function onTouchStart(event: React.TouchEvent) {\n    const touch = event.changedTouches[0];\n    const { identifier } = touch;\n    const { currentTarget } = event;\n    const { right } = currentTarget.getBoundingClientRect();\n    const offset = right - touch.clientX;\n\n    if (offset > 11) { // +1px to account for the border size\n      return;\n    }\n  }\n\n  function handleResize(x: number, target: Element) {\n    const width = x - target.getBoundingClientRect().left;\n    if (width > 0) {\n      onResize(column, width);\n    }\n  }\n\n  return cloneElement(children, {\n    onMouseDown,\n    onTouchStart,\n    children: (\n      <>\n        {children.props.children}\n        <div className=\"rdg-header-cell-resizer\" />\n      </>\n    )\n  });\n}\n","import React, { createElement } from 'react';\nimport clsx from 'clsx';\nimport { CalculatedColumn } from './types';\nimport { HeaderRowProps } from './HeaderRow';\nimport SortableHeaderCell from './headerCells/SortableHeaderCell';\nimport ResizableHeaderCell from './headerCells/ResizableHeaderCell';\nimport { SortDirection } from './enums';\n\nfunction getAriaSort(sortDirection?: SortDirection) {\n  switch (sortDirection) {\n    case 'ASC':\n      return 'ascending';\n    case 'DESC':\n      return 'descending';\n    default:\n      return 'none';\n  }\n}\n\ntype SharedHeaderRowProps<R> = Pick<HeaderRowProps<R, never>,\n| 'sortColumn'\n| 'sortDirection'\n| 'onSort'\n| 'allRowsSelected'\n>;\n\nexport interface HeaderCellProps<R> extends SharedHeaderRowProps<R> {\n  column: CalculatedColumn<R>;\n  lastFrozenColumnIndex: number;\n  onResize: (column: CalculatedColumn<R>, width: number) => void;\n  onAllRowsSelectionChange: (checked: boolean) => void;\n}\n\nexport default function HeaderCell<R>({\n  column,\n  lastFrozenColumnIndex,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumn,\n  sortDirection,\n  onSort\n}: HeaderCellProps<R>) {\n  function getCell() {\n    if (!column.headerRenderer) return column.name;\n\n    return createElement(column.headerRenderer, { column, allRowsSelected, onAllRowsSelectionChange });\n  }\n\n  let cell = getCell();\n\n  if (column.sortable) {\n    cell = (\n      <SortableHeaderCell\n        column={column}\n        onSort={onSort}\n        sortColumn={sortColumn}\n        sortDirection={sortDirection}\n      >\n        {cell}\n      </SortableHeaderCell>\n    );\n  }\n\n  const className = clsx('rdg-cell', column.headerCellClass, {\n    'rdg-cell-frozen': column.frozen,\n    'rdg-cell-frozen-last': column.idx === lastFrozenColumnIndex\n  });\n\n  const style: React.CSSProperties = {\n    width: column.width,\n    left: column.left\n  };\n\n  cell = (\n    <div\n      role=\"columnheader\"\n      aria-colindex={column.idx + 1}\n      aria-sort={sortColumn === column.key ? getAriaSort(sortDirection) : undefined}\n      className={className}\n      style={style}\n    >\n      {cell}\n    </div>\n  );\n\n  if (column.resizable) {\n    cell = (\n      <ResizableHeaderCell\n        column={column}\n        onResize={onResize}\n      >\n        {cell as React.ReactElement<React.ComponentProps<'div'>>}\n      </ResizableHeaderCell>\n    );\n  }\n  \n  return cell;\n}\n","import React, { useCallback, memo } from 'react';\nimport HeaderCell from './HeaderCell';\nimport { CalculatedColumn } from './types';\nimport { assertIsValidKey } from './utils';\nimport { DataGridProps } from './DataGrid';\n\ntype SharedDataGridProps<R, K extends keyof R> = Pick<DataGridProps<R, K>,\n  | 'rows'\n  | 'onSelectedRowsChange'\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n  | 'rowKey'\n>;\n\nexport interface HeaderRowProps<R, K extends keyof R> extends SharedDataGridProps<R, K> {\n  allRowsSelected: boolean;\n  columns: readonly CalculatedColumn<R>[];\n  lastFrozenColumnIndex: number;\n  onColumnResize: (column: CalculatedColumn<R>, width: number) => void;\n}\n\nfunction HeaderRow<R, K extends keyof R>({\n  columns,\n  lastFrozenColumnIndex,\n  rows,\n  rowKey,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumn,\n  sortDirection,\n  onSort\n}: HeaderRowProps<R, K>) {\n  const handleAllRowsSelectionChange = useCallback((checked: boolean) => {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKey(rowKey);\n    const newSelectedRows = new Set<R[K]>();\n    if (checked) {\n      for (const row of rows) {\n        newSelectedRows.add(row[rowKey]);\n      }\n    }\n    onSelectedRowsChange(newSelectedRows);\n  }, [onSelectedRowsChange, rows, rowKey]);\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={1} // aria-rowindex is 1 based\n      className=\"rdg-header-row\"\n    >\n      {columns.map(column => {\n        return (\n          <HeaderCell<R>\n            key={column.key}\n            column={column}\n            lastFrozenColumnIndex={lastFrozenColumnIndex}\n            onResize={onColumnResize}\n            allRowsSelected={allRowsSelected}\n            onAllRowsSelectionChange={handleAllRowsSelectionChange}\n            onSort={onSort}\n            sortColumn={sortColumn}\n            sortDirection={sortDirection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(HeaderRow) as <R, K extends keyof R>(props: HeaderRowProps<R, K>) => JSX.Element;\n","import React, { createElement, memo } from 'react';\nimport clsx from 'clsx';\n\nimport { CalculatedColumn, Filters } from './types';\nimport { DataGridProps } from './DataGrid';\n\ntype SharedDataGridProps<R> = Pick<DataGridProps<R, never>,\n  | 'filters'\n  | 'onFiltersChange'\n>;\n\nexport interface FilterRowProps<R> extends SharedDataGridProps<R> {\n  lastFrozenColumnIndex: number;\n  columns: readonly CalculatedColumn<R>[];\n}\n\nfunction FilterRow<R>({\n  columns,\n  lastFrozenColumnIndex,\n  filters,\n  onFiltersChange\n}: FilterRowProps<R>) {\n  function onChange(key: string, value: unknown) {\n    const newFilters: Filters = { ...filters };\n    newFilters[key] = value;\n    onFiltersChange?.(newFilters);\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={2}\n      className=\"rdg-filter-row\"\n    >\n      {columns.map(column => {\n        const { key } = column;\n\n        const className = clsx('rdg-cell', {\n          'rdg-cell-frozen': column.frozen,\n          'rdg-cell-frozen-last': column.idx === lastFrozenColumnIndex\n        });\n        const style: React.CSSProperties = {\n          width: column.width,\n          left: column.left\n        };\n\n        return (\n          <div\n            key={key}\n            style={style}\n            className={className}\n          >\n            {column.filterRenderer && createElement(column.filterRenderer, {\n              column,\n              value: filters?.[column.key],\n              onChange: value => onChange(key, value)\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(FilterRow) as <R>(props: FilterRowProps<R>) => JSX.Element;\n","import React from 'react';\nimport { Editor, EditorProps } from '../types';\n\ntype Props = Pick<EditorProps<string>, 'value' | 'column' | 'onCommit'>;\n\nexport default class SimpleTextEditor extends React.Component<Props> implements Editor<{ [key: string]: string }> {\n  private readonly input = React.createRef<HTMLInputElement>();\n\n  getInputNode() {\n    return this.input.current;\n  }\n\n  getValue() {\n    return {\n      [this.props.column.key]: this.input.current!.value\n    };\n  }\n\n  render() {\n    return (\n      <input\n        className=\"rdg-text-editor\"\n        ref={this.input}\n        defaultValue={this.props.value}\n        onBlur={this.props.onCommit}\n      />\n    );\n  }\n}\n","import React, { useState, useLayoutEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\ninterface Props {\n  children: React.ReactNode;\n  target: Element;\n}\n\nexport default function EditorPortal({ target, children }: Props) {\n  // Keep track of when the modal element is added to the DOM\n  const [isMounted, setIsMounted] = useState(false);\n\n  useLayoutEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  // Don't render the portal until the component has mounted,\n  // So the portal can safely access the DOM.\n  if (!isMounted) {\n    return null;\n  }\n\n  return ReactDOM.createPortal(children, target);\n}\n","import React, { KeyboardEvent, useRef, useState, useLayoutEffect, useCallback, useEffect } from 'react';\nimport clsx from 'clsx';\n\nimport { CalculatedColumn, Editor, Omit, SharedEditorContainerProps } from '../types';\nimport { useClickOutside } from '../hooks';\nimport { preventDefault } from '../utils';\n\nexport interface EditorContainerProps<R> extends Omit<SharedEditorContainerProps, 'editorPortalTarget'> {\n  rowIdx: number;\n  row: R;\n  column: CalculatedColumn<R>;\n  top: number;\n  left: number;\n}\n\nexport default function EditorContainer<R>({\n  rowIdx,\n  column,\n  row,\n  rowHeight,\n  left,\n  top,\n  onCommit,\n  onCommitCancel,\n  scrollLeft,\n  scrollTop,\n  firstEditorKeyPress: key\n}: EditorContainerProps<R>) {\n  const editorRef = useRef<Editor>(null);\n  const changeCommitted = useRef(false);\n  const changeCanceled = useRef(false);\n  const [isValid, setValid] = useState(true);\n  const prevScrollLeft = useRef(scrollLeft);\n  const prevScrollTop = useRef(scrollTop);\n  const isUnmounting = useRef(false);\n  const onClickCapture = useClickOutside(commit);\n\n  const getInputNode = useCallback(() => editorRef.current?.getInputNode(), []);\n\n  const commitCancel = useCallback(() => {\n    changeCanceled.current = true;\n    onCommitCancel();\n  }, [onCommitCancel]);\n\n  useLayoutEffect(() => {\n    const inputNode = getInputNode();\n\n    if (inputNode instanceof HTMLElement) {\n      inputNode.focus();\n    }\n    if (inputNode instanceof HTMLInputElement) {\n      inputNode.select();\n    }\n  }, [getInputNode]);\n\n  // close editor when scrolling\n  useEffect(() => {\n    if (scrollLeft !== prevScrollLeft.current || scrollTop !== prevScrollTop.current) {\n      commitCancel();\n    }\n  }, [commitCancel, scrollLeft, scrollTop]);\n\n  useEffect(() => () => {\n    isUnmounting.current = true;\n  }, []);\n\n  // commit changes when editor is closed\n  useEffect(() => () => {\n    if (isUnmounting.current && !changeCommitted.current && !changeCanceled.current) {\n      commit();\n    }\n  });\n\n  function getInitialValue() {\n    const value = row[column.key as keyof R];\n    if (key === 'Delete' || key === 'Backspace') {\n      return '';\n    }\n    if (key === 'Enter') {\n      return value;\n    }\n\n    return key || value;\n  }\n\n  function isCaretAtBeginningOfInput(): boolean {\n    const inputNode = getInputNode();\n    return inputNode instanceof HTMLInputElement\n      && inputNode.selectionEnd === 0;\n  }\n\n  function isCaretAtEndOfInput(): boolean {\n    const inputNode = getInputNode();\n    return inputNode instanceof HTMLInputElement\n      && inputNode.selectionStart === inputNode.value.length;\n  }\n\n  function editorHasResults(): boolean {\n    return editorRef.current?.hasResults?.() ?? false;\n  }\n\n  function editorIsSelectOpen(): boolean {\n    return editorRef.current?.isSelectOpen?.() ?? false;\n  }\n\n  function isNewValueValid(value: unknown): boolean {\n    const isValid = editorRef.current?.validate?.(value);\n    if (typeof isValid === 'boolean') {\n      setValid(isValid);\n      return isValid;\n    }\n    return true;\n  }\n\n  function preventDefaultNavigation(key: string): boolean {\n    return (key === 'ArrowLeft' && !isCaretAtBeginningOfInput())\n      || (key === 'ArrowRight' && !isCaretAtEndOfInput())\n      || (key === 'Escape' && editorIsSelectOpen())\n      || (['ArrowUp', 'ArrowDown'].includes(key) && editorHasResults());\n  }\n\n  function commit(): void {\n    if (!editorRef.current) return;\n    const updated = editorRef.current.getValue();\n    if (isNewValueValid(updated)) {\n      changeCommitted.current = true;\n      const cellKey = column.key;\n      onCommit({ cellKey, rowIdx, updated });\n    }\n  }\n\n  function onKeyDown(e: KeyboardEvent) {\n    if (preventDefaultNavigation(e.key)) {\n      e.stopPropagation();\n    } else if (['Enter', 'Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {\n      commit();\n    } else if (e.key === 'Escape') {\n      commitCancel();\n    }\n  }\n\n  const className = clsx('rdg-editor-container', {\n    'rdg-editor-invalid': !isValid\n  });\n\n  return (\n    <div\n      className={className}\n      style={{ height: rowHeight, width: column.width, left, top }}\n      onClickCapture={onClickCapture}\n      onKeyDown={onKeyDown}\n      onContextMenu={preventDefault}\n    >\n    </div>\n  );\n}\n","import { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div react-data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div react-data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the document\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the document click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the document is set using document.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\nexport function useClickOutside(onClickOutside: () => void) {\n  const isClickedInside = useRef(false);\n\n  useEffect(() => {\n    function handleDocumentClick() {\n      if (isClickedInside.current) {\n        isClickedInside.current = false;\n      } else {\n        onClickOutside();\n      }\n    }\n\n    document.addEventListener('click', handleDocumentClick);\n    return () => {\n      document.removeEventListener('click', handleDocumentClick);\n    };\n  });\n\n  return function onClickCapture() {\n    isClickedInside.current = true;\n  };\n}\n","import React, { memo, useRef, forwardRef } from 'react';\nimport clsx from 'clsx';\nimport { EditorContainer, EditorPortal } from './editors';\nimport { CellRendererProps } from './types';\nimport { wrapEvent } from './utils';\nimport { useCombinedRefs } from './hooks';\n\nfunction Cell<R>({\n  className,\n  column,\n  isCopied,\n  isDraggedOver,\n  isRowSelected,\n  lastFrozenColumnIndex,\n  row,\n  rowIdx,\n  eventBus,\n  selectedCellProps,\n  onRowClick,\n  onKeyDown,\n  onClick,\n  onDoubleClick,\n  onContextMenu,\n  ...props\n}: CellRendererProps<R>, ref: React.Ref<HTMLDivElement>) {\n  const cellRef = useRef<HTMLDivElement>(null);\n  const isSelected = selectedCellProps !== undefined;\n  const isEditing = selectedCellProps?.mode === 'EDIT';\n\n  const { cellClass } = column;\n  className = clsx(\n    'rdg-cell',\n    {\n      'rdg-cell-frozen': column.frozen,\n      'rdg-cell-frozen-last': column.idx === lastFrozenColumnIndex,\n      'rdg-cell-selected': isSelected,\n      'rdg-cell-copied': isCopied,\n      'rdg-cell-dragged-over': isDraggedOver\n    },\n    typeof cellClass === 'function' ? cellClass(row) : cellClass,\n    className\n  );\n\n  function selectCell(openEditor?: boolean) {\n    eventBus.dispatch('SELECT_CELL', { idx: column.idx, rowIdx }, openEditor);\n  }\n\n  function handleClick() {\n    selectCell();\n    onRowClick?.(rowIdx, row, column);\n  }\n\n  function handleContextMenu() {\n    selectCell();\n  }\n\n  function handleDoubleClick() {\n    selectCell(true);\n  }\n\n  function onRowSelectionChange(checked: boolean, isShiftClick: boolean) {\n    eventBus.dispatch('SELECT_ROW', { rowIdx, checked, isShiftClick });\n  }\n\n  function getCellContent() {\n    if (selectedCellProps && selectedCellProps.mode === 'EDIT') {\n      const { editorPortalTarget, ...editorProps } = selectedCellProps.editorContainerProps;\n      const { scrollTop: docTop, scrollLeft: docLeft } = document.scrollingElement || document.documentElement;\n      const { left, top } = cellRef.current!.getBoundingClientRect();\n      const gridLeft = left + docLeft;\n      const gridTop = top + docTop;\n\n      return (\n        <EditorPortal target={editorPortalTarget}>\n          <EditorContainer<R>\n            {...editorProps}\n            rowIdx={rowIdx}\n            row={row}\n            column={column}\n            left={gridLeft}\n            top={gridTop}\n          />\n        </EditorPortal>\n      );\n    }\n\n    return (\n      <>\n        <column.formatter\n          column={column}\n          rowIdx={rowIdx}\n          row={row}\n          isCellSelected={isSelected}\n          isRowSelected={isRowSelected}\n          onRowSelectionChange={onRowSelectionChange}\n        />\n        {selectedCellProps?.dragHandleProps && (\n          <div className=\"rdg-cell-drag-handle\" {...selectedCellProps.dragHandleProps} />\n        )}\n      </>\n    );\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected={isSelected}\n      ref={useCombinedRefs(cellRef, ref)}\n      className={className}\n      style={{\n        width: column.width,\n        left: column.left\n      }}\n      onKeyDown={selectedCellProps ? wrapEvent(selectedCellProps.onKeyDown, onKeyDown) : onKeyDown}\n      onClick={isEditing ? onClick : wrapEvent(handleClick, onClick)}\n      onDoubleClick={isEditing ? onDoubleClick : wrapEvent(handleDoubleClick, onDoubleClick)}\n      onContextMenu={isEditing ? onContextMenu : wrapEvent(handleContextMenu, onContextMenu)}\n      {...props}\n    >\n      {getCellContent()}\n    </div>\n  );\n}\n\nexport default memo(forwardRef(Cell)) as <R>(props: CellRendererProps<R>) => JSX.Element;\n","import React, { memo } from 'react';\nimport clsx from 'clsx';\nimport Cell from './Cell';\nimport { RowRendererProps } from './types';\nimport { wrapEvent } from './utils';\n\nfunction Row<R>({\n  cellRenderer: CellRenderer = Cell,\n  className,\n  eventBus,\n  rowIdx,\n  isRowSelected,\n  lastFrozenColumnIndex,\n  copiedCellIdx,\n  draggedOverCellIdx,\n  row,\n  viewportColumns,\n  selectedCellProps,\n  onRowClick,\n  rowClass,\n  setDraggedOverRowIdx,\n  onMouseEnter,\n  top,\n  'aria-rowindex': ariaRowIndex,\n  'aria-selected': ariaSelected,\n  ...props\n}: RowRendererProps<R>) {\n  function handleDragEnter() {\n    setDraggedOverRowIdx?.(rowIdx);\n  }\n  className = clsx(\n    'rdg-row',\n    `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`,\n    { 'rdg-row-selected': isRowSelected },\n    rowClass?.(row),\n    className\n  );\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={ariaRowIndex}\n      aria-selected={ariaSelected}\n      className={className}\n      onMouseEnter={wrapEvent(handleDragEnter, onMouseEnter)}\n      style={{ top }}\n      {...props}\n    >\n      {viewportColumns.map(column => (\n        <CellRenderer\n          key={column.key}\n          rowIdx={rowIdx}\n          column={column}\n          lastFrozenColumnIndex={lastFrozenColumnIndex}\n          row={row}\n          isCopied={copiedCellIdx === column.idx}\n          isDraggedOver={draggedOverCellIdx === column.idx}\n          isRowSelected={isRowSelected}\n          eventBus={eventBus}\n          selectedCellProps={selectedCellProps?.idx === column.idx ? selectedCellProps : undefined}\n          onRowClick={onRowClick}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default memo(Row) as <R>(props: RowRendererProps<R>) => JSX.Element;\n","import React, {\n  createElement,\n  useState,\n  useRef,\n  useEffect,\n  useImperativeHandle,\n  useCallback,\n  useLayoutEffect,\n  forwardRef\n} from 'react';\nimport clsx from 'clsx';\nimport { useGridWidth, useViewportColumns } from './hooks';\nimport EventBus from './EventBus';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport { ValueFormatter } from './formatters';\nimport {\n  assertIsValidKey,\n  canExitGrid,\n  getColumnScrollPosition,\n  getNextSelectedCellPosition,\n  getScrollbarSize,\n  getVerticalRangeToRender,\n  isCtrlKeyHeldDown,\n  isSelectedCellEditable,\n} from './utils';\nimport {\n  CalculatedColumn,\n  CheckCellIsEditableEvent,\n  Column,\n  Filters,\n  FormatterProps,\n  Position,\n  RowRendererProps,\n  RowsUpdateEvent,\n  SelectRowEvent,\n  CommitEvent,\n  SelectedCellProps\n} from './types';\nimport { CellNavigationMode, SortDirection, UpdateActions } from './enums';\n\ninterface SelectCellState extends Position {\n  mode: 'SELECT';\n}\n\ninterface EditCellState extends Position {\n  mode: 'EDIT';\n  key: string | null;\n}\n\nexport interface DataGridHandle {\n  scrollToColumn: (colIdx: number) => void;\n  scrollToRow: (rowIdx: number) => void;\n  selectCell: (position: Position, openEditor?: boolean) => void;\n}\n\ntype SharedDivProps = Pick<React.HTMLAttributes<HTMLDivElement>,\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'aria-describedby'\n>;\n\nexport interface DataGridProps<R, K extends keyof R> extends SharedDivProps {\n  /**\n   * Grid and data Props\n   */\n  /** An array of objects representing each column on the grid */\n  columns: readonly Column<R>[];\n  /** A function called for each rendered row that should return a plain key/value pair object */\n  rows: readonly R[];\n  /** The primary key property of each row */\n  rowKey?: K;\n  /**\n   * Callback called whenever row data is updated\n   * When editing is enabled, this callback will be called for the following scenarios\n   * 1. Using the supplied editor of the column. The default editor is the SimpleTextEditor.\n   * 2. Copy/pasting the value from one cell to another <kbd>CTRL</kbd>+<kbd>C</kbd>, <kbd>CTRL</kbd>+<kbd>V</kbd>\n   * 3. Update multiple cells by dragging the fill handle of a cell up or down to a destination cell.\n   * 4. Update all cells under a given cell by double clicking the cell's fill handle.\n   */\n  onRowsUpdate?: <E extends RowsUpdateEvent>(event: E) => void;\n  /**\n   * Dimensions props\n   */\n  /** The width of the grid in pixels */\n  width?: number;\n  /** The height of the grid in pixels */\n  height?: number;\n  /** Minimum column width in pixels */\n  minColumnWidth?: number;\n  /** The height of each row in pixels */\n  rowHeight?: number;\n  /** The height of the header row in pixels */\n  headerRowHeight?: number;\n  /** The height of the header filter row in pixels */\n  headerFiltersHeight?: number;\n  /**\n   * Feature props\n   */\n  /** Set of selected row keys */\n  selectedRows?: ReadonlySet<R[K]>;\n  /** Function called whenever row selection is changed */\n  onSelectedRowsChange?: (selectedRows: Set<R[K]>) => void;\n  /** The key of the column which is currently being sorted */\n  sortColumn?: string;\n  /** The direction to sort the sortColumn*/\n  sortDirection?: SortDirection;\n  /** Function called whenever grid is sorted*/\n  onSort?: (columnKey: string, direction: SortDirection) => void;\n  filters?: Filters;\n  onFiltersChange?: (filters: Filters) => void;\n  /**\n   * Custom renderers\n   */\n  defaultFormatter?: React.ComponentType<FormatterProps<R>>;\n  rowRenderer?: React.ComponentType<RowRendererProps<R>>;\n  emptyRowsRenderer?: React.ComponentType;\n  /**\n   * Event props\n   */\n  /** Function called whenever a row is clicked */\n  onRowClick?: (rowIdx: number, row: R, column: CalculatedColumn<R>) => void;\n  /** Called when the grid is scrolled */\n  onScroll?: (event: React.UIEvent<HTMLDivElement>) => void;\n  /** Called when a column is resized */\n  onColumnResize?: (idx: number, width: number) => void;\n  /** Function called whenever selected cell is changed */\n  onSelectedCellChange?: (position: Position) => void;\n  /** called before cell is set active, returns a boolean to determine whether cell is editable */\n  onCheckCellIsEditable?: (event: CheckCellIsEditableEvent<R>) => boolean;\n  /**\n   * Toggles and modes\n   */\n  /** Toggles whether filters row is displayed or not */\n  enableFilters?: boolean;\n  enableCellCopyPaste?: boolean;\n  enableCellDragAndDrop?: boolean;\n  cellNavigationMode?: CellNavigationMode;\n  /**\n   * Miscellaneous\n   */\n  editorPortalTarget?: Element;\n  rowClass?: (row: R) => string | undefined;\n}\n\n/**\n * Main API Component to render a data grid of rows and columns\n *\n * @example\n *\n * <DataGrid columns={columns} rows={rows} />\n*/\nfunction DataGrid<R, K extends keyof R>({\n    // Grid and data Props\n    columns: rawColumns,\n    rows,\n    rowKey,\n    onRowsUpdate,\n    // Dimensions props\n    width,\n    height = 350,\n    minColumnWidth = 80,\n    rowHeight = 46,\n    headerRowHeight = 28,\n    headerFiltersHeight = 45,\n    // Feature props\n    selectedRows,\n    onSelectedRowsChange,\n    sortColumn,\n    sortDirection,\n    onSort,\n    filters,\n    onFiltersChange,\n    // Custom renderers\n    defaultFormatter = ValueFormatter,\n    rowRenderer: RowRenderer = Row,\n    emptyRowsRenderer,\n    // Event props\n    onRowClick,\n    onScroll,\n    onColumnResize,\n    onSelectedCellChange,\n    onCheckCellIsEditable,\n    // Toggles and modes\n    enableFilters = false,\n    enableCellCopyPaste = false,\n    enableCellDragAndDrop = false,\n    cellNavigationMode = CellNavigationMode.NONE,\n    // Miscellaneous\n    editorPortalTarget = document.body,\n    rowClass,\n    // ARIA\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    'aria-describedby': ariaDescribedBy\n}: DataGridProps<R, K>, ref: React.Ref<DataGridHandle>) {\n  /**\n   * states\n   */\n  const [eventBus] = useState(() => new EventBus());\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState<ReadonlyMap<string, number>>(() => new Map());\n  const [selectedPosition, setSelectedPosition] = useState<SelectCellState | EditCellState>({ idx: -1, rowIdx: -1, mode: 'SELECT' });\n  const [copiedPosition, setCopiedPosition] = useState<Position & { value: unknown } | null>(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState<number | undefined>(undefined);\n\n  const setDraggedOverRowIdx = useCallback((rowIdx?: number) => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  /**\n   * refs\n   */\n  const focusSinkRef = useRef<HTMLDivElement>(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n\n  /**\n   * computed values\n   */\n  const [gridRef, gridWidth] = useGridWidth(width);\n  const viewportWidth = gridWidth - 2; // 2 for border width;\n  const headerRowsCount = enableFilters ? 2 : 1;\n  const isSelectable = selectedRows !== undefined && onSelectedRowsChange !== undefined;\n\n  const { columns, viewportColumns, totalColumnWidth, lastFrozenColumnIndex } = useViewportColumns({\n    columns: rawColumns,\n    minColumnWidth,\n    columnWidths,\n    defaultFormatter,\n    scrollLeft,\n    viewportWidth\n  });\n\n  const totalHeaderHeight = headerRowHeight + (enableFilters ? headerFiltersHeight : 0);\n  const clientHeight = height\n    - 2 // border width\n    - totalHeaderHeight\n    - (totalColumnWidth > viewportWidth ? getScrollbarSize() : 0);\n\n  const [rowOverscanStartIdx, rowOverscanEndIdx] = getVerticalRangeToRender(\n    clientHeight,\n    rowHeight,\n    scrollTop,\n    rows.length\n  );\n\n  /**\n   * effects\n   */\n  useLayoutEffect(() => {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) return;\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n    const column = columns[selectedPosition.idx];\n    if (column.formatterOptions?.focusable) return; // Let the formatter handle focus\n    focusSinkRef.current!.focus();\n  });\n\n  useEffect(() => {\n    if (!onSelectedRowsChange) return;\n\n    const handleRowSelectionChange = ({ rowIdx, checked, isShiftClick }: SelectRowEvent) => {\n      assertIsValidKey(rowKey);\n      const newSelectedRows = new Set(selectedRows);\n      const rowId = rows[rowIdx][rowKey];\n\n      if (checked) {\n        newSelectedRows.add(rowId);\n        const previousRowIdx = lastSelectedRowIdx.current;\n        lastSelectedRowIdx.current = rowIdx;\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n          const step = Math.sign(rowIdx - previousRowIdx);\n          for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n            newSelectedRows.add(rows[i][rowKey]);\n          }\n        }\n      } else {\n        newSelectedRows.delete(rowId);\n        lastSelectedRowIdx.current = -1;\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n    };\n\n    return eventBus.subscribe('SELECT_ROW', handleRowSelectionChange);\n  }, [eventBus, onSelectedRowsChange, rows, rowKey, selectedRows]);\n\n  useEffect(() => {\n    return eventBus.subscribe('SELECT_CELL', selectCell);\n  });\n\n  useImperativeHandle(ref, () => ({\n    scrollToColumn(idx: number) {\n      scrollToCell({ idx });\n    },\n    scrollToRow(rowIdx: number) {\n      const { current } = gridRef;\n      if (!current) return;\n      current.scrollTop = rowIdx * rowHeight;\n    },\n    selectCell\n  }));\n\n  /**\n   * event handlers\n   */\n  function handleKeyDown(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (enableCellCopyPaste && isCtrlKeyHeldDown(event) && isCellWithinBounds(selectedPosition)) {\n      // event.key may be uppercase `C` or `V`\n      const lowerCaseKey = event.key.toLowerCase();\n      if (lowerCaseKey === 'c') {\n        handleCopy();\n        return;\n      }\n      if (lowerCaseKey === 'v') {\n        handlePaste();\n        return;\n      }\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedPosition(null);\n        return;\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n      default:\n        if (isCellWithinBounds(selectedPosition)) {\n          handleCellInput(event);\n        }\n        break;\n    }\n  }\n\n  function handleScroll(event: React.UIEvent<HTMLDivElement>) {\n    const { scrollTop, scrollLeft } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll?.(event);\n  }\n\n  const handleColumnResize = useCallback((column: CalculatedColumn<R>, width: number) => {\n    const newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n\n    onColumnResize?.(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n\n  function handleCommit({ cellKey, rowIdx, updated }: CommitEvent) {\n    onRowsUpdate?.({\n      cellKey,\n      fromRow: rowIdx,\n      toRow: rowIdx,\n      updated,\n      action: UpdateActions.CELL_UPDATE\n    });\n\n    closeEditor();\n  }\n\n  function handleCopy() {\n    const { idx, rowIdx } = selectedPosition;\n    const value = rows[rowIdx][columns[idx].key as keyof R];\n    setCopiedPosition({ idx, rowIdx, value });\n  }\n\n  function handlePaste() {\n    if (\n      copiedPosition === null\n      || !isCellEditable(selectedPosition)\n      || (copiedPosition.idx === selectedPosition.idx && copiedPosition.rowIdx === selectedPosition.rowIdx)\n    ) {\n      return;\n    }\n\n    const { rowIdx: toRow } = selectedPosition;\n\n    const cellKey = columns[selectedPosition.idx].key;\n    const { rowIdx: fromRow, idx, value } = copiedPosition;\n    const fromCellKey = columns[idx].key;\n\n    onRowsUpdate?.({\n      cellKey,\n      fromRow,\n      toRow,\n      updated: { [cellKey]: value } as unknown as never,\n      action: UpdateActions.COPY_PASTE,\n      fromCellKey\n    });\n  }\n\n  function handleCellInput(event: React.KeyboardEvent<HTMLDivElement>) {\n    const { key } = event;\n    const canOpenEditor = selectedPosition.mode === 'SELECT' && isCellEditable(selectedPosition);\n\n    if (canOpenEditor && (key === 'Enter')) {\n      setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, key, mode: 'EDIT' }));\n    }\n  }\n\n  function handleDragEnd() {\n    if (latestDraggedOverRowIdx.current === undefined) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const column = columns[idx];\n    const cellKey = column.key;\n    const value = rows[rowIdx][cellKey as keyof R];\n\n    onRowsUpdate?.({\n      cellKey,\n      fromRow: rowIdx,\n      toRow: latestDraggedOverRowIdx.current,\n      updated: { [cellKey]: value } as unknown as never,\n      action: UpdateActions.CELL_DRAG\n    });\n\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event: React.MouseEvent<HTMLDivElement, MouseEvent>) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event: MouseEvent) {\n      // Trigger onMouseup in edge cases where we release the mouse button but `mouseup` isn't triggered,\n      // for example when releasing the mouse button outside the iframe the grid is rendered in.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event: React.MouseEvent<HTMLDivElement>) {\n    event.stopPropagation();\n\n    const column = columns[selectedPosition.idx];\n    const cellKey = column.key;\n    const value = rows[selectedPosition.rowIdx][cellKey as keyof R];\n\n    onRowsUpdate?.({\n      cellKey,\n      fromRow: selectedPosition.rowIdx,\n      toRow: rows.length - 1,\n      updated: { [cellKey]: value } as unknown as never,\n      action: UpdateActions.COLUMN_FILL\n    });\n  }\n\n  /**\n   * utils\n   */\n  function isCellWithinBounds({ idx, rowIdx }: Position): boolean {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= 0 && idx < columns.length;\n  }\n\n  function isCellEditable(position: Position): boolean {\n    return isCellWithinBounds(position)\n      && isSelectedCellEditable<R>({ columns, rows, selectedPosition: position, onCheckCellIsEditable });\n  }\n\n  function selectCell(position: Position, enableEditor = false): void {\n    if (!isCellWithinBounds(position)) return;\n\n    if (enableEditor && isCellEditable(position)) {\n      setSelectedPosition({ ...position, mode: 'EDIT', key: null });\n    } else {\n      setSelectedPosition({ ...position, mode: 'SELECT' });\n    }\n    onSelectedCellChange?.({ ...position });\n  }\n\n  function closeEditor() {\n    setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, mode: 'SELECT' }));\n  }\n\n  function getFrozenColumnsWidth(): number {\n    if (lastFrozenColumnIndex === -1) return 0;\n    const lastFrozenCol = columns[lastFrozenColumnIndex];\n    return lastFrozenCol.left + lastFrozenCol.width;\n  }\n\n  function scrollToCell({ idx, rowIdx }: Partial<Position>): void {\n    const { current } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const { clientWidth } = current;\n      const { left, width } = columns[idx];\n      const isCellAtLeftBoundary = left < scrollLeft + width + getFrozenColumnsWidth();\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        const newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key: string, ctrlKey: boolean, shiftKey: boolean): Position {\n    const { idx, rowIdx } = selectedPosition;\n    switch (key) {\n      case 'ArrowUp':\n        return { idx, rowIdx: rowIdx - 1 };\n      case 'ArrowDown':\n        return { idx, rowIdx: rowIdx + 1 };\n      case 'ArrowLeft':\n        return { idx: idx - 1, rowIdx };\n      case 'ArrowRight':\n        return { idx: idx + 1, rowIdx };\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? { idx: columns.length - 1, rowIdx: rows.length - 1 } : { idx: 0, rowIdx: 0 };\n        }\n        return { idx: idx + (shiftKey ? -1 : 1), rowIdx };\n      case 'Home':\n        return ctrlKey ? { idx: 0, rowIdx: 0 } : { idx: 0, rowIdx };\n      case 'End':\n        return ctrlKey ? { idx: columns.length - 1, rowIdx: rows.length - 1 } : { idx: columns.length - 1, rowIdx };\n      case 'PageUp':\n        return { idx, rowIdx: rowIdx - Math.floor(clientHeight / rowHeight) };\n      case 'PageDown':\n        return { idx, rowIdx: rowIdx + Math.floor(clientHeight / rowHeight) };\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event: React.KeyboardEvent<HTMLDivElement>) {\n    const { key, shiftKey } = event;\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    let nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n    let mode = cellNavigationMode;\n    if (key === 'Tab') {\n      // If we are in a position to leave the grid, stop editing but stay in that cell\n      if (canExitGrid({ shiftKey, cellNavigationMode, columns, rowsCount: rows.length, selectedPosition })) {\n        // Allow focus to leave the grid so the next control in the tab order can be focused\n        return;\n      }\n\n      mode = cellNavigationMode === CellNavigationMode.NONE\n        ? CellNavigationMode.CHANGE_ROW\n        : cellNavigationMode;\n    }\n\n    // Do not allow focus to leave\n    event.preventDefault();\n\n    nextPosition = getNextSelectedCellPosition<R>({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx: number): number | undefined {\n    if (draggedOverRowIdx === undefined) return;\n    const { rowIdx } = selectedPosition;\n\n    const isDraggedOver = rowIdx < draggedOverRowIdx\n      ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx\n      : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx: number): SelectedCellProps | undefined {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorContainerProps: {\n          editorPortalTarget,\n          rowHeight,\n          scrollLeft,\n          scrollTop,\n          firstEditorKeyPress: selectedPosition.key,\n          onCommit: handleCommit,\n          onCommitCancel: closeEditor\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition)\n        ? { onMouseDown: handleMouseDown, onDoubleClick: handleDoubleClick }\n        : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      let key: string | number = rowIdx;\n      let isRowSelected = false;\n      if (rowKey !== undefined) {\n        const rowId = row[rowKey];\n        isRowSelected = selectedRows?.has(rowId) ?? false;\n        if (typeof rowId === 'string' || typeof rowId === 'number') {\n          key = rowId;\n        }\n      }\n      rowElements.push(\n        <RowRenderer\n          aria-rowindex={headerRowsCount + rowIdx + 1}\n          aria-selected={isSelectable ? isRowSelected : undefined}\n          key={key}\n          rowIdx={rowIdx}\n          row={row}\n          viewportColumns={viewportColumns}\n          lastFrozenColumnIndex={lastFrozenColumnIndex}\n          eventBus={eventBus}\n          isRowSelected={isRowSelected}\n          onRowClick={onRowClick}\n          rowClass={rowClass}\n          top={rowIdx * rowHeight + totalHeaderHeight}\n          copiedCellIdx={copiedPosition?.rowIdx === rowIdx ? copiedPosition.idx : undefined}\n          draggedOverCellIdx={getDraggedOverCellIdx(rowIdx)}\n          setDraggedOverRowIdx={isDragging ? setDraggedOverRowIdx : undefined}\n          selectedCellProps={getSelectedCellProps(rowIdx)}\n        />\n      );\n    }\n\n    return rowElements;\n  }\n\n  // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition({ idx: -1, rowIdx: -1, mode: 'SELECT' });\n    setCopiedPosition(null);\n    setDraggedOverRowIdx(undefined);\n  }\n\n  return (\n    <div\n      role=\"grid\"\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-describedby={ariaDescribedBy}\n      aria-multiselectable={isSelectable ? true : undefined}\n      aria-colcount={columns.length}\n      aria-rowcount={headerRowsCount + rows.length}\n      className={clsx('rdg', { 'rdg-viewport-dragging': isDragging })}\n      style={{\n        width,\n        height,\n        '--header-row-height': `${headerRowHeight}px`,\n        '--filter-row-height': `${headerFiltersHeight}px`,\n        '--column-width': `${totalColumnWidth}px`,\n        '--row-height': `${rowHeight}px`\n      } as unknown as React.CSSProperties}\n      ref={gridRef}\n      onScroll={handleScroll}\n    >\n      <HeaderRow<R, K>\n        rowKey={rowKey}\n        rows={rows}\n        columns={viewportColumns}\n        onColumnResize={handleColumnResize}\n        lastFrozenColumnIndex={lastFrozenColumnIndex}\n        allRowsSelected={selectedRows?.size === rows.length}\n        onSelectedRowsChange={onSelectedRowsChange}\n        sortColumn={sortColumn}\n        sortDirection={sortDirection}\n        onSort={onSort}\n      />\n      {enableFilters && (\n        <FilterRow<R>\n          lastFrozenColumnIndex={lastFrozenColumnIndex}\n          columns={viewportColumns}\n          filters={filters}\n          onFiltersChange={onFiltersChange}\n        />\n      )}\n      {rows.length === 0 && emptyRowsRenderer ? createElement(emptyRowsRenderer) : (\n        <>\n          <div\n            ref={focusSinkRef}\n            tabIndex={0}\n            className=\"rdg-focus-sink\"\n            onKeyDown={handleKeyDown}\n          />\n          <div style={{ height: Math.max(rows.length * rowHeight, clientHeight) }} />\n          {getViewportRows()}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default forwardRef(\n  DataGrid as React.RefForwardingComponent<DataGridHandle>\n) as <R, K extends keyof R>(props: DataGridProps<R, K> & { ref?: React.Ref<DataGridHandle> }) => JSX.Element;\n","import { useRef, useState, useLayoutEffect } from 'react';\n\nexport function useGridWidth<T>(width?: number): [React.RefObject<HTMLDivElement>, number] {\n  const gridRef = useRef<HTMLDivElement>(null);\n  const [gridWidth, setGridWidth] = useState(0);\n\n  useLayoutEffect(() => {\n    // Do not calculate the width if width is provided\n    if (typeof width === 'number') return;\n    function onResize() {\n    // Immediately re-render when the component is mounted to get valid columnMetrics.\n      setGridWidth(gridRef.current!.getBoundingClientRect().width);\n    }\n    onResize();\n\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [width]);\n\n  return [gridRef, width || gridWidth];\n}\n","import React, { useState, useMemo, useRef, useCallback } from 'react';\r\nimport { Column, RowsUpdateEvent, CalculatedColumn } from './types';\r\nimport { UpdateActions } from './enums';\r\nimport { SelectColumn } from './Columns';\r\nimport DataGrid, { DataGridHandle } from './DataGrid';\r\nimport { ImageFormatter } from './formatters';\r\nimport { AutoSizer } from 'react-virtualized';\r\nimport faker from 'faker';\r\n\r\ninterface Row {\r\n  id: string;\r\n  avatar: string;\r\n  contact: string;\r\n  totalValue: string;\r\n  location: string;\r\n  deals: number;\r\n  tags: string;\r\n}\r\n\r\nfunction createFakeRowObjectData(index: number): Row {\r\n  return {\r\n    id: `id_${index}`,\r\n    avatar: faker.image.avatar(),\r\n    contact: `${faker.name.firstName()} ${faker.name.lastName()}`,\r\n    totalValue: (Math.floor(Math.random() * 100000)).toString(),\r\n    location: faker.address.city() + ', ' + faker.address.state() + ', ' + faker.address.country(),\r\n    deals: Math.floor(Math.random() * 10),\r\n    tags: faker.lorem.words()\r\n  };\r\n}\r\n\r\nfunction createRows(numberOfRows: number): Row[] {\r\n  const rows: Row[] = [];\r\n  for (let i = 0; i < numberOfRows; i++) {\r\n    rows[i] = createFakeRowObjectData(i);\r\n  }\r\n  return rows;\r\n}\r\n\r\nfunction isAtBottom(event: React.UIEvent<HTMLDivElement>): boolean {\r\n  const target = event.target as HTMLDivElement;\r\n  return target.clientHeight + target.scrollTop === target.scrollHeight;\r\n}\r\n\r\nfunction loadMoreRows(newRowsCount: number, length: number): Promise<Row[]> {\r\n  return new Promise(resolve => {\r\n    const newRows: Row[] = [];\r\n    for (let i = 0; i < newRowsCount; i++) {\r\n      newRows[i] = createFakeRowObjectData(i + length);\r\n    }\r\n    setTimeout(() => resolve(newRows), 1000);\r\n  });\r\n}\r\n\r\nexport default function Contacts() {\r\n  const [rows, setRows] = useState<Row[]>(createRows(200));\r\n  const [selectedRows, setSelectedRows] = useState(() => new Set<string>());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const gridRef = useRef<DataGridHandle>(null);\r\n\r\n  const columns = useMemo((): Column<Row>[] => [ \r\n    SelectColumn,\r\n    // {\r\n    //   key: 'id',\r\n    //   name: 'ID',\r\n    //   width: 50\r\n    // },\r\n    {\r\n      key: 'avatar',\r\n      name: 'Contact',\r\n      width: 40,\r\n      formatter: ({ row }) => <ImageFormatter value={row.avatar} />\r\n    },\r\n    {\r\n      key: 'contact',\r\n      name: '',\r\n      width: 270\r\n    },\r\n    {\r\n      key: 'totalValue',\r\n      name: 'Total Value',\r\n      width: 150\r\n    },\r\n    {\r\n      key: 'location',\r\n      name: 'Location',\r\n      width: 350\r\n    },\r\n    {\r\n      key: 'deals',\r\n      name: 'Deals',\r\n      width: 50\r\n    },\r\n    {\r\n      key: 'tags',\r\n      name: 'Tags',\r\n    }\r\n  ], []);\r\n\r\n  const handleRowUpdate = useCallback(({ fromRow, toRow, updated, action }: RowsUpdateEvent<Partial<Row>>): void => {\r\n    const newRows = [...rows];\r\n    let start: number;\r\n    let end: number;\r\n\r\n    if (action === UpdateActions.COPY_PASTE) {\r\n      start = toRow;\r\n      end = toRow;\r\n    } else {\r\n      start = Math.min(fromRow, toRow);\r\n      end = Math.max(fromRow, toRow);\r\n    }\r\n\r\n    for (let i = start; i <= end; i++) {\r\n      newRows[i] = { ...newRows[i], ...updated };\r\n    }\r\n\r\n    setRows(newRows);\r\n  }, [rows]);\r\n\r\n  const handleRowClick = useCallback((rowIdx: number, row: Row, column: CalculatedColumn<Row>) => {\r\n    if (column.key === 'title') {\r\n      gridRef.current?.selectCell({ rowIdx, idx: column.idx }, true);\r\n    }\r\n  }, []);\r\n\r\n  async function handleScroll(event: React.UIEvent<HTMLDivElement>) {\r\n    if (!isAtBottom(event)) return;\r\n\r\n    setIsLoading(true);\r\n\r\n    const newRows = await loadMoreRows(50, rows.length);\r\n\r\n    setRows([...rows, ...newRows]);\r\n    setIsLoading(false);\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <AutoSizer>\r\n        {({ height, width }) => (\r\n          <>\r\n            <DataGrid\r\n              ref={gridRef}\r\n              columns={columns}\r\n              rows={rows}\r\n              rowKey=\"id\"\r\n              onRowsUpdate={handleRowUpdate}\r\n              onRowClick={handleRowClick}\r\n              rowHeight={46}\r\n              width={width}\r\n              height={height - 40}\r\n              selectedRows={selectedRows}\r\n              onScroll={handleScroll}\r\n              onSelectedRowsChange={setSelectedRows}\r\n              rowClass={row => row.id.includes('7') ? 'highlight' : undefined}\r\n              enableCellCopyPaste\r\n              enableCellDragAndDrop\r\n            />\r\n            {isLoading && <div className=\"load-more-rows-tag\">Loading more rows...</div>}\r\n          </>\r\n        )}\r\n      </AutoSizer>\r\n    </>\r\n  );\r\n}","import React from 'react';\r\nimport Contacts from '../components/Contacts'\r\n\r\nexport default function ContactsContainer() {\r\n  return <Contacts />;\r\n}"],"sourceRoot":""}